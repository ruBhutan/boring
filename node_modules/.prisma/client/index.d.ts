
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Tour
 * 
 */
export type Tour = $Result.DefaultSelection<Prisma.$TourPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Guide
 * 
 */
export type Guide = $Result.DefaultSelection<Prisma.$GuidePayload>
/**
 * Model Itinerary
 * 
 */
export type Itinerary = $Result.DefaultSelection<Prisma.$ItineraryPayload>
/**
 * Model ItineraryDay
 * 
 */
export type ItineraryDay = $Result.DefaultSelection<Prisma.$ItineraryDayPayload>
/**
 * Model CustomTourRequest
 * 
 */
export type CustomTourRequest = $Result.DefaultSelection<Prisma.$CustomTourRequestPayload>
/**
 * Model TourOperator
 * 
 */
export type TourOperator = $Result.DefaultSelection<Prisma.$TourOperatorPayload>
/**
 * Model Festival
 * 
 */
export type Festival = $Result.DefaultSelection<Prisma.$FestivalPayload>
/**
 * Model FestivalBooking
 * 
 */
export type FestivalBooking = $Result.DefaultSelection<Prisma.$FestivalBookingPayload>
/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model HotelRoom
 * 
 */
export type HotelRoom = $Result.DefaultSelection<Prisma.$HotelRoomPayload>
/**
 * Model HotelBooking
 * 
 */
export type HotelBooking = $Result.DefaultSelection<Prisma.$HotelBookingPayload>
/**
 * Model UserAccount
 * 
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model UserFeedback
 * 
 */
export type UserFeedback = $Result.DefaultSelection<Prisma.$UserFeedbackPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.guide`: Exposes CRUD operations for the **Guide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guides
    * const guides = await prisma.guide.findMany()
    * ```
    */
  get guide(): Prisma.GuideDelegate<ExtArgs>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<ExtArgs>;

  /**
   * `prisma.itineraryDay`: Exposes CRUD operations for the **ItineraryDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItineraryDays
    * const itineraryDays = await prisma.itineraryDay.findMany()
    * ```
    */
  get itineraryDay(): Prisma.ItineraryDayDelegate<ExtArgs>;

  /**
   * `prisma.customTourRequest`: Exposes CRUD operations for the **CustomTourRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomTourRequests
    * const customTourRequests = await prisma.customTourRequest.findMany()
    * ```
    */
  get customTourRequest(): Prisma.CustomTourRequestDelegate<ExtArgs>;

  /**
   * `prisma.tourOperator`: Exposes CRUD operations for the **TourOperator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourOperators
    * const tourOperators = await prisma.tourOperator.findMany()
    * ```
    */
  get tourOperator(): Prisma.TourOperatorDelegate<ExtArgs>;

  /**
   * `prisma.festival`: Exposes CRUD operations for the **Festival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Festivals
    * const festivals = await prisma.festival.findMany()
    * ```
    */
  get festival(): Prisma.FestivalDelegate<ExtArgs>;

  /**
   * `prisma.festivalBooking`: Exposes CRUD operations for the **FestivalBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FestivalBookings
    * const festivalBookings = await prisma.festivalBooking.findMany()
    * ```
    */
  get festivalBooking(): Prisma.FestivalBookingDelegate<ExtArgs>;

  /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs>;

  /**
   * `prisma.hotelRoom`: Exposes CRUD operations for the **HotelRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelRooms
    * const hotelRooms = await prisma.hotelRoom.findMany()
    * ```
    */
  get hotelRoom(): Prisma.HotelRoomDelegate<ExtArgs>;

  /**
   * `prisma.hotelBooking`: Exposes CRUD operations for the **HotelBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelBookings
    * const hotelBookings = await prisma.hotelBooking.findMany()
    * ```
    */
  get hotelBooking(): Prisma.HotelBookingDelegate<ExtArgs>;

  /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs>;

  /**
   * `prisma.userFeedback`: Exposes CRUD operations for the **UserFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeedbacks
    * const userFeedbacks = await prisma.userFeedback.findMany()
    * ```
    */
  get userFeedback(): Prisma.UserFeedbackDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Tour: 'Tour',
    Booking: 'Booking',
    Inquiry: 'Inquiry',
    Testimonial: 'Testimonial',
    BlogPost: 'BlogPost',
    Guide: 'Guide',
    Itinerary: 'Itinerary',
    ItineraryDay: 'ItineraryDay',
    CustomTourRequest: 'CustomTourRequest',
    TourOperator: 'TourOperator',
    Festival: 'Festival',
    FestivalBooking: 'FestivalBooking',
    Hotel: 'Hotel',
    HotelRoom: 'HotelRoom',
    HotelBooking: 'HotelBooking',
    UserAccount: 'UserAccount',
    UserFeedback: 'UserFeedback'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "tour" | "booking" | "inquiry" | "testimonial" | "blogPost" | "guide" | "itinerary" | "itineraryDay" | "customTourRequest" | "tourOperator" | "festival" | "festivalBooking" | "hotel" | "hotelRoom" | "hotelBooking" | "userAccount" | "userFeedback"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Tour: {
        payload: Prisma.$TourPayload<ExtArgs>
        fields: Prisma.TourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findFirst: {
            args: Prisma.TourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findMany: {
            args: Prisma.TourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          create: {
            args: Prisma.TourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          createMany: {
            args: Prisma.TourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          delete: {
            args: Prisma.TourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          update: {
            args: Prisma.TourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          deleteMany: {
            args: Prisma.TourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.TourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Guide: {
        payload: Prisma.$GuidePayload<ExtArgs>
        fields: Prisma.GuideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findFirst: {
            args: Prisma.GuideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findMany: {
            args: Prisma.GuideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          create: {
            args: Prisma.GuideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          createMany: {
            args: Prisma.GuideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          delete: {
            args: Prisma.GuideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          update: {
            args: Prisma.GuideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          deleteMany: {
            args: Prisma.GuideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          aggregate: {
            args: Prisma.GuideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuide>
          }
          groupBy: {
            args: Prisma.GuideGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideCountArgs<ExtArgs>
            result: $Utils.Optional<GuideCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: Prisma.$ItineraryPayload<ExtArgs>
        fields: Prisma.ItineraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      ItineraryDay: {
        payload: Prisma.$ItineraryDayPayload<ExtArgs>
        fields: Prisma.ItineraryDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          findFirst: {
            args: Prisma.ItineraryDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          findMany: {
            args: Prisma.ItineraryDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>[]
          }
          create: {
            args: Prisma.ItineraryDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          createMany: {
            args: Prisma.ItineraryDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          update: {
            args: Prisma.ItineraryDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          aggregate: {
            args: Prisma.ItineraryDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItineraryDay>
          }
          groupBy: {
            args: Prisma.ItineraryDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryDayCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryDayCountAggregateOutputType> | number
          }
        }
      }
      CustomTourRequest: {
        payload: Prisma.$CustomTourRequestPayload<ExtArgs>
        fields: Prisma.CustomTourRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomTourRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomTourRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          findFirst: {
            args: Prisma.CustomTourRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomTourRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          findMany: {
            args: Prisma.CustomTourRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>[]
          }
          create: {
            args: Prisma.CustomTourRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          createMany: {
            args: Prisma.CustomTourRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomTourRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>[]
          }
          delete: {
            args: Prisma.CustomTourRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          update: {
            args: Prisma.CustomTourRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          deleteMany: {
            args: Prisma.CustomTourRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomTourRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomTourRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          aggregate: {
            args: Prisma.CustomTourRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomTourRequest>
          }
          groupBy: {
            args: Prisma.CustomTourRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomTourRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomTourRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CustomTourRequestCountAggregateOutputType> | number
          }
        }
      }
      TourOperator: {
        payload: Prisma.$TourOperatorPayload<ExtArgs>
        fields: Prisma.TourOperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourOperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourOperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          findFirst: {
            args: Prisma.TourOperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourOperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          findMany: {
            args: Prisma.TourOperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>[]
          }
          create: {
            args: Prisma.TourOperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          createMany: {
            args: Prisma.TourOperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourOperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>[]
          }
          delete: {
            args: Prisma.TourOperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          update: {
            args: Prisma.TourOperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          deleteMany: {
            args: Prisma.TourOperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourOperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourOperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          aggregate: {
            args: Prisma.TourOperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourOperator>
          }
          groupBy: {
            args: Prisma.TourOperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourOperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourOperatorCountArgs<ExtArgs>
            result: $Utils.Optional<TourOperatorCountAggregateOutputType> | number
          }
        }
      }
      Festival: {
        payload: Prisma.$FestivalPayload<ExtArgs>
        fields: Prisma.FestivalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FestivalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FestivalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          findFirst: {
            args: Prisma.FestivalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FestivalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          findMany: {
            args: Prisma.FestivalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>[]
          }
          create: {
            args: Prisma.FestivalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          createMany: {
            args: Prisma.FestivalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FestivalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>[]
          }
          delete: {
            args: Prisma.FestivalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          update: {
            args: Prisma.FestivalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          deleteMany: {
            args: Prisma.FestivalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FestivalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FestivalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          aggregate: {
            args: Prisma.FestivalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFestival>
          }
          groupBy: {
            args: Prisma.FestivalGroupByArgs<ExtArgs>
            result: $Utils.Optional<FestivalGroupByOutputType>[]
          }
          count: {
            args: Prisma.FestivalCountArgs<ExtArgs>
            result: $Utils.Optional<FestivalCountAggregateOutputType> | number
          }
        }
      }
      FestivalBooking: {
        payload: Prisma.$FestivalBookingPayload<ExtArgs>
        fields: Prisma.FestivalBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FestivalBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FestivalBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          findFirst: {
            args: Prisma.FestivalBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FestivalBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          findMany: {
            args: Prisma.FestivalBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>[]
          }
          create: {
            args: Prisma.FestivalBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          createMany: {
            args: Prisma.FestivalBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FestivalBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>[]
          }
          delete: {
            args: Prisma.FestivalBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          update: {
            args: Prisma.FestivalBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          deleteMany: {
            args: Prisma.FestivalBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FestivalBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FestivalBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          aggregate: {
            args: Prisma.FestivalBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFestivalBooking>
          }
          groupBy: {
            args: Prisma.FestivalBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FestivalBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FestivalBookingCountArgs<ExtArgs>
            result: $Utils.Optional<FestivalBookingCountAggregateOutputType> | number
          }
        }
      }
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      HotelRoom: {
        payload: Prisma.$HotelRoomPayload<ExtArgs>
        fields: Prisma.HotelRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          findFirst: {
            args: Prisma.HotelRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          findMany: {
            args: Prisma.HotelRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>[]
          }
          create: {
            args: Prisma.HotelRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          createMany: {
            args: Prisma.HotelRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>[]
          }
          delete: {
            args: Prisma.HotelRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          update: {
            args: Prisma.HotelRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          deleteMany: {
            args: Prisma.HotelRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          aggregate: {
            args: Prisma.HotelRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelRoom>
          }
          groupBy: {
            args: Prisma.HotelRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelRoomCountArgs<ExtArgs>
            result: $Utils.Optional<HotelRoomCountAggregateOutputType> | number
          }
        }
      }
      HotelBooking: {
        payload: Prisma.$HotelBookingPayload<ExtArgs>
        fields: Prisma.HotelBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findFirst: {
            args: Prisma.HotelBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findMany: {
            args: Prisma.HotelBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          create: {
            args: Prisma.HotelBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          createMany: {
            args: Prisma.HotelBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          delete: {
            args: Prisma.HotelBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          update: {
            args: Prisma.HotelBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          deleteMany: {
            args: Prisma.HotelBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          aggregate: {
            args: Prisma.HotelBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelBooking>
          }
          groupBy: {
            args: Prisma.HotelBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelBookingCountArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingCountAggregateOutputType> | number
          }
        }
      }
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      UserFeedback: {
        payload: Prisma.$UserFeedbackPayload<ExtArgs>
        fields: Prisma.UserFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findFirst: {
            args: Prisma.UserFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findMany: {
            args: Prisma.UserFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          create: {
            args: Prisma.UserFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          createMany: {
            args: Prisma.UserFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          delete: {
            args: Prisma.UserFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          update: {
            args: Prisma.UserFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.UserFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          aggregate: {
            args: Prisma.UserFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeedback>
          }
          groupBy: {
            args: Prisma.UserFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TourCountOutputType
   */

  export type TourCountOutputType = {
    bookings: number
    itineraries: number
    UserFeedback: number
  }

  export type TourCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | TourCountOutputTypeCountBookingsArgs
    itineraries?: boolean | TourCountOutputTypeCountItinerariesArgs
    UserFeedback?: boolean | TourCountOutputTypeCountUserFeedbackArgs
  }

  // Custom InputTypes
  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountUserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }


  /**
   * Count Type GuideCountOutputType
   */

  export type GuideCountOutputType = {
    guidedItineraries: number
    drivenItineraries: number
  }

  export type GuideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guidedItineraries?: boolean | GuideCountOutputTypeCountGuidedItinerariesArgs
    drivenItineraries?: boolean | GuideCountOutputTypeCountDrivenItinerariesArgs
  }

  // Custom InputTypes
  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideCountOutputType
     */
    select?: GuideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeCountGuidedItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }

  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeCountDrivenItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * Count Type ItineraryCountOutputType
   */

  export type ItineraryCountOutputType = {
    days: number
    assignedCustomTourRequests: number
    UserFeedback: number
  }

  export type ItineraryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    days?: boolean | ItineraryCountOutputTypeCountDaysArgs
    assignedCustomTourRequests?: boolean | ItineraryCountOutputTypeCountAssignedCustomTourRequestsArgs
    UserFeedback?: boolean | ItineraryCountOutputTypeCountUserFeedbackArgs
  }

  // Custom InputTypes
  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryCountOutputType
     */
    select?: ItineraryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountAssignedCustomTourRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourRequestWhereInput
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountUserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }


  /**
   * Count Type TourOperatorCountOutputType
   */

  export type TourOperatorCountOutputType = {
    tours: number
  }

  export type TourOperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | TourOperatorCountOutputTypeCountToursArgs
  }

  // Custom InputTypes
  /**
   * TourOperatorCountOutputType without action
   */
  export type TourOperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperatorCountOutputType
     */
    select?: TourOperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourOperatorCountOutputType without action
   */
  export type TourOperatorCountOutputTypeCountToursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }


  /**
   * Count Type FestivalCountOutputType
   */

  export type FestivalCountOutputType = {
    bookings: number
  }

  export type FestivalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | FestivalCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * FestivalCountOutputType without action
   */
  export type FestivalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalCountOutputType
     */
    select?: FestivalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FestivalCountOutputType without action
   */
  export type FestivalCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalBookingWhereInput
  }


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    rooms: number
    bookings: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | HotelCountOutputTypeCountRoomsArgs
    bookings?: boolean | HotelCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRoomWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type HotelRoomCountOutputType
   */

  export type HotelRoomCountOutputType = {
    bookings: number
  }

  export type HotelRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | HotelRoomCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * HotelRoomCountOutputType without action
   */
  export type HotelRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoomCountOutputType
     */
    select?: HotelRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelRoomCountOutputType without action
   */
  export type HotelRoomCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type UserAccountCountOutputType
   */

  export type UserAccountCountOutputType = {
    feedbacks: number
  }

  export type UserAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | UserAccountCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccountCountOutputType
     */
    select?: UserAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    rating: number | null
    reviewCount: number | null
    maxGroupSize: number | null
    tourOperatorId: number | null
  }

  export type TourSumAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    rating: number | null
    reviewCount: number | null
    maxGroupSize: number | null
    tourOperatorId: number | null
  }

  export type TourMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    duration: number | null
    price: number | null
    category: string | null
    imageUrl: string | null
    rating: number | null
    reviewCount: number | null
    isActive: boolean | null
    maxGroupSize: number | null
    difficulty: string | null
    bestSeason: string | null
    tourOperatorId: number | null
  }

  export type TourMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    duration: number | null
    price: number | null
    category: string | null
    imageUrl: string | null
    rating: number | null
    reviewCount: number | null
    isActive: boolean | null
    maxGroupSize: number | null
    difficulty: string | null
    bestSeason: string | null
    tourOperatorId: number | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    name: number
    description: number
    duration: number
    price: number
    category: number
    imageUrl: number
    rating: number
    reviewCount: number
    highlights: number
    isActive: number
    maxGroupSize: number
    difficulty: number
    bestSeason: number
    includes: number
    excludes: number
    tourOperatorId: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    rating?: true
    reviewCount?: true
    maxGroupSize?: true
    tourOperatorId?: true
  }

  export type TourSumAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    rating?: true
    reviewCount?: true
    maxGroupSize?: true
    tourOperatorId?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    category?: true
    imageUrl?: true
    rating?: true
    reviewCount?: true
    isActive?: true
    maxGroupSize?: true
    difficulty?: true
    bestSeason?: true
    tourOperatorId?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    category?: true
    imageUrl?: true
    rating?: true
    reviewCount?: true
    isActive?: true
    maxGroupSize?: true
    difficulty?: true
    bestSeason?: true
    tourOperatorId?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    category?: true
    imageUrl?: true
    rating?: true
    reviewCount?: true
    highlights?: true
    isActive?: true
    maxGroupSize?: true
    difficulty?: true
    bestSeason?: true
    includes?: true
    excludes?: true
    tourOperatorId?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
    orderBy?: TourOrderByWithAggregationInput | TourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    id: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating: number
    reviewCount: number
    highlights: string[]
    isActive: boolean
    maxGroupSize: number
    difficulty: string
    bestSeason: string
    includes: string[]
    excludes: string[]
    tourOperatorId: number | null
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    highlights?: boolean
    isActive?: boolean
    maxGroupSize?: boolean
    difficulty?: boolean
    bestSeason?: boolean
    includes?: boolean
    excludes?: boolean
    tourOperatorId?: boolean
    bookings?: boolean | Tour$bookingsArgs<ExtArgs>
    itineraries?: boolean | Tour$itinerariesArgs<ExtArgs>
    TourOperator?: boolean | Tour$TourOperatorArgs<ExtArgs>
    UserFeedback?: boolean | Tour$UserFeedbackArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    highlights?: boolean
    isActive?: boolean
    maxGroupSize?: boolean
    difficulty?: boolean
    bestSeason?: boolean
    includes?: boolean
    excludes?: boolean
    tourOperatorId?: boolean
    TourOperator?: boolean | Tour$TourOperatorArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    highlights?: boolean
    isActive?: boolean
    maxGroupSize?: boolean
    difficulty?: boolean
    bestSeason?: boolean
    includes?: boolean
    excludes?: boolean
    tourOperatorId?: boolean
  }

  export type TourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Tour$bookingsArgs<ExtArgs>
    itineraries?: boolean | Tour$itinerariesArgs<ExtArgs>
    TourOperator?: boolean | Tour$TourOperatorArgs<ExtArgs>
    UserFeedback?: boolean | Tour$UserFeedbackArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TourOperator?: boolean | Tour$TourOperatorArgs<ExtArgs>
  }

  export type $TourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tour"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      itineraries: Prisma.$ItineraryPayload<ExtArgs>[]
      TourOperator: Prisma.$TourOperatorPayload<ExtArgs> | null
      UserFeedback: Prisma.$UserFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      duration: number
      price: number
      category: string
      imageUrl: string
      rating: number
      reviewCount: number
      highlights: string[]
      isActive: boolean
      maxGroupSize: number
      difficulty: string
      bestSeason: string
      includes: string[]
      excludes: string[]
      tourOperatorId: number | null
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type TourGetPayload<S extends boolean | null | undefined | TourDefaultArgs> = $Result.GetResult<Prisma.$TourPayload, S>

  type TourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tour'], meta: { name: 'Tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFindUniqueArgs>(args: SelectSubset<T, TourFindUniqueArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFindFirstArgs>(args?: SelectSubset<T, TourFindFirstArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFindManyArgs>(args?: SelectSubset<T, TourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends TourCreateArgs>(args: SelectSubset<T, TourCreateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tours.
     * @param {TourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCreateManyArgs>(args?: SelectSubset<T, TourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tours and returns the data saved in the database.
     * @param {TourCreateManyAndReturnArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tours and only return the `id`
     * const tourWithIdOnly = await prisma.tour.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourCreateManyAndReturnArgs>(args?: SelectSubset<T, TourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends TourDeleteArgs>(args: SelectSubset<T, TourDeleteArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourUpdateArgs>(args: SelectSubset<T, TourUpdateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourDeleteManyArgs>(args?: SelectSubset<T, TourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourUpdateManyArgs>(args: SelectSubset<T, TourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends TourUpsertArgs>(args: SelectSubset<T, TourUpsertArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tour model
   */
  readonly fields: TourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Tour$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tour$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    itineraries<T extends Tour$itinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Tour$itinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    TourOperator<T extends Tour$TourOperatorArgs<ExtArgs> = {}>(args?: Subset<T, Tour$TourOperatorArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    UserFeedback<T extends Tour$UserFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Tour$UserFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tour model
   */ 
  interface TourFieldRefs {
    readonly id: FieldRef<"Tour", 'Int'>
    readonly name: FieldRef<"Tour", 'String'>
    readonly description: FieldRef<"Tour", 'String'>
    readonly duration: FieldRef<"Tour", 'Int'>
    readonly price: FieldRef<"Tour", 'Int'>
    readonly category: FieldRef<"Tour", 'String'>
    readonly imageUrl: FieldRef<"Tour", 'String'>
    readonly rating: FieldRef<"Tour", 'Float'>
    readonly reviewCount: FieldRef<"Tour", 'Int'>
    readonly highlights: FieldRef<"Tour", 'String[]'>
    readonly isActive: FieldRef<"Tour", 'Boolean'>
    readonly maxGroupSize: FieldRef<"Tour", 'Int'>
    readonly difficulty: FieldRef<"Tour", 'String'>
    readonly bestSeason: FieldRef<"Tour", 'String'>
    readonly includes: FieldRef<"Tour", 'String[]'>
    readonly excludes: FieldRef<"Tour", 'String[]'>
    readonly tourOperatorId: FieldRef<"Tour", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tour findUnique
   */
  export type TourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findFirst
   */
  export type TourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findMany
   */
  export type TourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour create
   */
  export type TourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
  }

  /**
   * Tour createMany
   */
  export type TourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tour createManyAndReturn
   */
  export type TourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tour update
   */
  export type TourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
  }

  /**
   * Tour upsert
   */
  export type TourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
  }

  /**
   * Tour delete
   */
  export type TourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
  }

  /**
   * Tour.bookings
   */
  export type Tour$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tour.itineraries
   */
  export type Tour$itinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Tour.TourOperator
   */
  export type Tour$TourOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    where?: TourOperatorWhereInput
  }

  /**
   * Tour.UserFeedback
   */
  export type Tour$UserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * Tour without action
   */
  export type TourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    tourId: number | null
    groupSize: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    tourId: number | null
    groupSize: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    tourId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    travelDate: string | null
    groupSize: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    tourId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    travelDate: string | null
    groupSize: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tourId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    travelDate: number
    groupSize: number
    specialRequests: number
    status: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    tourId?: true
    groupSize?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    tourId?: true
    groupSize?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    travelDate: string
    groupSize: number
    specialRequests: string | null
    status: string
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tourId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      travelDate: string
      groupSize: number
      specialRequests: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly tourId: FieldRef<"Booking", 'Int'>
    readonly firstName: FieldRef<"Booking", 'String'>
    readonly lastName: FieldRef<"Booking", 'String'>
    readonly email: FieldRef<"Booking", 'String'>
    readonly phone: FieldRef<"Booking", 'String'>
    readonly travelDate: FieldRef<"Booking", 'String'>
    readonly groupSize: FieldRef<"Booking", 'Int'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    id: number | null
  }

  export type InquirySumAggregateOutputType = {
    id: number | null
  }

  export type InquiryMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    tourInterest: number
    preferredDates: number
    groupSize: number
    message: number
    status: number
    createdAt: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    id?: true
  }

  export type InquirySumAggregateInputType = {
    id?: true
  }

  export type InquiryMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string
    createdAt: Date
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }


  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      tourInterest: string | null
      preferredDates: string | null
      groupSize: string | null
      message: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inquiries and returns the data saved in the database.
     * @param {InquiryCreateManyAndReturnArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */ 
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'Int'>
    readonly firstName: FieldRef<"Inquiry", 'String'>
    readonly lastName: FieldRef<"Inquiry", 'String'>
    readonly email: FieldRef<"Inquiry", 'String'>
    readonly phone: FieldRef<"Inquiry", 'String'>
    readonly tourInterest: FieldRef<"Inquiry", 'String'>
    readonly preferredDates: FieldRef<"Inquiry", 'String'>
    readonly groupSize: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'String'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry createManyAndReturn
   */
  export type InquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: number | null
    name: string | null
    country: string | null
    imageUrl: string | null
    text: string | null
    rating: number | null
    tripName: string | null
    duration: string | null
    isActive: boolean | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: number | null
    name: string | null
    country: string | null
    imageUrl: string | null
    text: string | null
    rating: number | null
    tripName: string | null
    duration: string | null
    isActive: boolean | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    name: number
    country: number
    imageUrl: number
    text: number
    rating: number
    tripName: number
    duration: number
    isActive: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive: boolean
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }


  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      country: string
      imageUrl: string
      text: string
      rating: number
      tripName: string
      duration: string
      isActive: boolean
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */ 
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'Int'>
    readonly name: FieldRef<"Testimonial", 'String'>
    readonly country: FieldRef<"Testimonial", 'String'>
    readonly imageUrl: FieldRef<"Testimonial", 'String'>
    readonly text: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly tripName: FieldRef<"Testimonial", 'String'>
    readonly duration: FieldRef<"Testimonial", 'String'>
    readonly isActive: FieldRef<"Testimonial", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    id: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    id: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: number | null
    title: string | null
    excerpt: string | null
    content: string | null
    imageUrl: string | null
    category: string | null
    author: string | null
    authorImage: string | null
    readTime: string | null
    publishedAt: Date | null
    isPublished: boolean | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: number | null
    title: string | null
    excerpt: string | null
    content: string | null
    imageUrl: string | null
    category: string | null
    author: string | null
    authorImage: string | null
    readTime: string | null
    publishedAt: Date | null
    isPublished: boolean | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    excerpt: number
    content: number
    imageUrl: number
    category: number
    author: number
    authorImage: number
    readTime: number
    publishedAt: number
    isPublished: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    id?: true
  }

  export type BlogPostSumAggregateInputType = {
    id?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt: Date
    isPublished: boolean
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }


  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      excerpt: string
      content: string
      imageUrl: string
      category: string
      author: string
      authorImage: string
      readTime: string
      publishedAt: Date
      isPublished: boolean
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'Int'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly imageUrl: FieldRef<"BlogPost", 'String'>
    readonly category: FieldRef<"BlogPost", 'String'>
    readonly author: FieldRef<"BlogPost", 'String'>
    readonly authorImage: FieldRef<"BlogPost", 'String'>
    readonly readTime: FieldRef<"BlogPost", 'String'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly isPublished: FieldRef<"BlogPost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
  }


  /**
   * Model Guide
   */

  export type AggregateGuide = {
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  export type GuideAvgAggregateOutputType = {
    id: number | null
  }

  export type GuideSumAggregateOutputType = {
    id: number | null
  }

  export type GuideMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    licenseImageUrl: string | null
    registrationType: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GuideMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    licenseImageUrl: string | null
    registrationType: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GuideCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    licenseImageUrl: number
    registrationType: number
    specializations: number
    status: number
    createdAt: number
    _all: number
  }


  export type GuideAvgAggregateInputType = {
    id?: true
  }

  export type GuideSumAggregateInputType = {
    id?: true
  }

  export type GuideMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    status?: true
    createdAt?: true
  }

  export type GuideMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    status?: true
    createdAt?: true
  }

  export type GuideCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    specializations?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type GuideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guide to aggregate.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guides
    **/
    _count?: true | GuideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideMaxAggregateInputType
  }

  export type GetGuideAggregateType<T extends GuideAggregateArgs> = {
        [P in keyof T & keyof AggregateGuide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuide[P]>
      : GetScalarType<T[P], AggregateGuide[P]>
  }




  export type GuideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideWhereInput
    orderBy?: GuideOrderByWithAggregationInput | GuideOrderByWithAggregationInput[]
    by: GuideScalarFieldEnum[] | GuideScalarFieldEnum
    having?: GuideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideCountAggregateInputType | true
    _avg?: GuideAvgAggregateInputType
    _sum?: GuideSumAggregateInputType
    _min?: GuideMinAggregateInputType
    _max?: GuideMaxAggregateInputType
  }

  export type GuideGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations: string[]
    status: string
    createdAt: Date
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  type GetGuideGroupByPayload<T extends GuideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideGroupByOutputType[P]>
            : GetScalarType<T[P], GuideGroupByOutputType[P]>
        }
      >
    >


  export type GuideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
    guidedItineraries?: boolean | Guide$guidedItinerariesArgs<ExtArgs>
    drivenItineraries?: boolean | Guide$drivenItinerariesArgs<ExtArgs>
    _count?: boolean | GuideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type GuideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guidedItineraries?: boolean | Guide$guidedItinerariesArgs<ExtArgs>
    drivenItineraries?: boolean | Guide$drivenItinerariesArgs<ExtArgs>
    _count?: boolean | GuideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guide"
    objects: {
      guidedItineraries: Prisma.$ItineraryPayload<ExtArgs>[]
      drivenItineraries: Prisma.$ItineraryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      licenseImageUrl: string
      registrationType: string
      specializations: string[]
      status: string
      createdAt: Date
    }, ExtArgs["result"]["guide"]>
    composites: {}
  }

  type GuideGetPayload<S extends boolean | null | undefined | GuideDefaultArgs> = $Result.GetResult<Prisma.$GuidePayload, S>

  type GuideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuideCountAggregateInputType | true
    }

  export interface GuideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guide'], meta: { name: 'Guide' } }
    /**
     * Find zero or one Guide that matches the filter.
     * @param {GuideFindUniqueArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideFindUniqueArgs>(args: SelectSubset<T, GuideFindUniqueArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guide that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuideFindUniqueOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideFindFirstArgs>(args?: SelectSubset<T, GuideFindFirstArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guides
     * const guides = await prisma.guide.findMany()
     * 
     * // Get first 10 Guides
     * const guides = await prisma.guide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideWithIdOnly = await prisma.guide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideFindManyArgs>(args?: SelectSubset<T, GuideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guide.
     * @param {GuideCreateArgs} args - Arguments to create a Guide.
     * @example
     * // Create one Guide
     * const Guide = await prisma.guide.create({
     *   data: {
     *     // ... data to create a Guide
     *   }
     * })
     * 
     */
    create<T extends GuideCreateArgs>(args: SelectSubset<T, GuideCreateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guides.
     * @param {GuideCreateManyArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideCreateManyArgs>(args?: SelectSubset<T, GuideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guides and returns the data saved in the database.
     * @param {GuideCreateManyAndReturnArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guides and only return the `id`
     * const guideWithIdOnly = await prisma.guide.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Guide.
     * @param {GuideDeleteArgs} args - Arguments to delete one Guide.
     * @example
     * // Delete one Guide
     * const Guide = await prisma.guide.delete({
     *   where: {
     *     // ... filter to delete one Guide
     *   }
     * })
     * 
     */
    delete<T extends GuideDeleteArgs>(args: SelectSubset<T, GuideDeleteArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guide.
     * @param {GuideUpdateArgs} args - Arguments to update one Guide.
     * @example
     * // Update one Guide
     * const guide = await prisma.guide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideUpdateArgs>(args: SelectSubset<T, GuideUpdateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guides.
     * @param {GuideDeleteManyArgs} args - Arguments to filter Guides to delete.
     * @example
     * // Delete a few Guides
     * const { count } = await prisma.guide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideDeleteManyArgs>(args?: SelectSubset<T, GuideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guides
     * const guide = await prisma.guide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideUpdateManyArgs>(args: SelectSubset<T, GuideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guide.
     * @param {GuideUpsertArgs} args - Arguments to update or create a Guide.
     * @example
     * // Update or create a Guide
     * const guide = await prisma.guide.upsert({
     *   create: {
     *     // ... data to create a Guide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guide we want to update
     *   }
     * })
     */
    upsert<T extends GuideUpsertArgs>(args: SelectSubset<T, GuideUpsertArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideCountArgs} args - Arguments to filter Guides to count.
     * @example
     * // Count the number of Guides
     * const count = await prisma.guide.count({
     *   where: {
     *     // ... the filter for the Guides we want to count
     *   }
     * })
    **/
    count<T extends GuideCountArgs>(
      args?: Subset<T, GuideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideAggregateArgs>(args: Subset<T, GuideAggregateArgs>): Prisma.PrismaPromise<GetGuideAggregateType<T>>

    /**
     * Group by Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideGroupByArgs['orderBy'] }
        : { orderBy?: GuideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guide model
   */
  readonly fields: GuideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guidedItineraries<T extends Guide$guidedItinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Guide$guidedItinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    drivenItineraries<T extends Guide$drivenItinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Guide$drivenItinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guide model
   */ 
  interface GuideFieldRefs {
    readonly id: FieldRef<"Guide", 'Int'>
    readonly name: FieldRef<"Guide", 'String'>
    readonly email: FieldRef<"Guide", 'String'>
    readonly phone: FieldRef<"Guide", 'String'>
    readonly licenseImageUrl: FieldRef<"Guide", 'String'>
    readonly registrationType: FieldRef<"Guide", 'String'>
    readonly specializations: FieldRef<"Guide", 'String[]'>
    readonly status: FieldRef<"Guide", 'String'>
    readonly createdAt: FieldRef<"Guide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guide findUnique
   */
  export type GuideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findUniqueOrThrow
   */
  export type GuideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findFirst
   */
  export type GuideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findFirstOrThrow
   */
  export type GuideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findMany
   */
  export type GuideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guides to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide create
   */
  export type GuideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The data needed to create a Guide.
     */
    data: XOR<GuideCreateInput, GuideUncheckedCreateInput>
  }

  /**
   * Guide createMany
   */
  export type GuideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide createManyAndReturn
   */
  export type GuideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide update
   */
  export type GuideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The data needed to update a Guide.
     */
    data: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
    /**
     * Choose, which Guide to update.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide updateMany
   */
  export type GuideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guides.
     */
    data: XOR<GuideUpdateManyMutationInput, GuideUncheckedUpdateManyInput>
    /**
     * Filter which Guides to update
     */
    where?: GuideWhereInput
  }

  /**
   * Guide upsert
   */
  export type GuideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The filter to search for the Guide to update in case it exists.
     */
    where: GuideWhereUniqueInput
    /**
     * In case the Guide found by the `where` argument doesn't exist, create a new Guide with this data.
     */
    create: XOR<GuideCreateInput, GuideUncheckedCreateInput>
    /**
     * In case the Guide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
  }

  /**
   * Guide delete
   */
  export type GuideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter which Guide to delete.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide deleteMany
   */
  export type GuideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guides to delete
     */
    where?: GuideWhereInput
  }

  /**
   * Guide.guidedItineraries
   */
  export type Guide$guidedItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Guide.drivenItineraries
   */
  export type Guide$drivenItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Guide without action
   */
  export type GuideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
  }


  /**
   * Model Itinerary
   */

  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryAvgAggregateOutputType = {
    id: number | null
    tourId: number | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
  }

  export type ItinerarySumAggregateOutputType = {
    id: number | null
    tourId: number | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
  }

  export type ItineraryMinAggregateOutputType = {
    id: number | null
    tourId: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ItineraryMaxAggregateOutputType = {
    id: number | null
    tourId: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ItineraryCountAggregateOutputType = {
    id: number
    tourId: number
    name: number
    description: number
    startDate: number
    endDate: number
    guideId: number
    driverId: number
    maxParticipants: number
    currentParticipants: number
    status: number
    createdAt: number
    _all: number
  }


  export type ItineraryAvgAggregateInputType = {
    id?: true
    tourId?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
  }

  export type ItinerarySumAggregateInputType = {
    id?: true
    tourId?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
  }

  export type ItineraryMinAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
  }

  export type ItineraryMaxAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
  }

  export type ItineraryCountAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithAggregationInput | ItineraryOrderByWithAggregationInput[]
    by: ItineraryScalarFieldEnum[] | ItineraryScalarFieldEnum
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _avg?: ItineraryAvgAggregateInputType
    _sum?: ItinerarySumAggregateInputType
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }

  export type ItineraryGroupByOutputType = {
    id: number
    tourId: number
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    guideId: number | null
    driverId: number | null
    maxParticipants: number
    currentParticipants: number
    status: string
    createdAt: Date
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
    days?: boolean | Itinerary$daysArgs<ExtArgs>
    assignedCustomTourRequests?: boolean | Itinerary$assignedCustomTourRequestsArgs<ExtArgs>
    UserFeedback?: boolean | Itinerary$UserFeedbackArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ItineraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
    days?: boolean | Itinerary$daysArgs<ExtArgs>
    assignedCustomTourRequests?: boolean | Itinerary$assignedCustomTourRequestsArgs<ExtArgs>
    UserFeedback?: boolean | Itinerary$UserFeedbackArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItineraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
  }

  export type $ItineraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Itinerary"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      guide: Prisma.$GuidePayload<ExtArgs> | null
      driver: Prisma.$GuidePayload<ExtArgs> | null
      days: Prisma.$ItineraryDayPayload<ExtArgs>[]
      assignedCustomTourRequests: Prisma.$CustomTourRequestPayload<ExtArgs>[]
      UserFeedback: Prisma.$UserFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tourId: number
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      guideId: number | null
      driverId: number | null
      maxParticipants: number
      currentParticipants: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["itinerary"]>
    composites: {}
  }

  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryDefaultArgs> = $Result.GetResult<Prisma.$ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryFindUniqueArgs>(args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Itinerary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryFindFirstArgs>(args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryFindManyArgs>(args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
     */
    create<T extends ItineraryCreateArgs>(args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Itineraries.
     * @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryCreateManyArgs>(args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itineraries and returns the data saved in the database.
     * @param {ItineraryCreateManyAndReturnArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itineraries and only return the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDeleteArgs>(args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryUpdateArgs>(args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDeleteManyArgs>(args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryUpdateManyArgs>(args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryUpsertArgs>(args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Itinerary model
   */
  readonly fields: ItineraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    guide<T extends Itinerary$guideArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$guideArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends Itinerary$driverArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$driverArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    days<T extends Itinerary$daysArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findMany"> | Null>
    assignedCustomTourRequests<T extends Itinerary$assignedCustomTourRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$assignedCustomTourRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findMany"> | Null>
    UserFeedback<T extends Itinerary$UserFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$UserFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Itinerary model
   */ 
  interface ItineraryFieldRefs {
    readonly id: FieldRef<"Itinerary", 'Int'>
    readonly tourId: FieldRef<"Itinerary", 'Int'>
    readonly name: FieldRef<"Itinerary", 'String'>
    readonly description: FieldRef<"Itinerary", 'String'>
    readonly startDate: FieldRef<"Itinerary", 'DateTime'>
    readonly endDate: FieldRef<"Itinerary", 'DateTime'>
    readonly guideId: FieldRef<"Itinerary", 'Int'>
    readonly driverId: FieldRef<"Itinerary", 'Int'>
    readonly maxParticipants: FieldRef<"Itinerary", 'Int'>
    readonly currentParticipants: FieldRef<"Itinerary", 'Int'>
    readonly status: FieldRef<"Itinerary", 'String'>
    readonly createdAt: FieldRef<"Itinerary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Itinerary findUnique
   */
  export type ItineraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findFirst
   */
  export type ItineraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }

  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Itinerary createManyAndReturn
   */
  export type ItineraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }

  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary.guide
   */
  export type Itinerary$guideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    where?: GuideWhereInput
  }

  /**
   * Itinerary.driver
   */
  export type Itinerary$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    where?: GuideWhereInput
  }

  /**
   * Itinerary.days
   */
  export type Itinerary$daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    where?: ItineraryDayWhereInput
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    cursor?: ItineraryDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * Itinerary.assignedCustomTourRequests
   */
  export type Itinerary$assignedCustomTourRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    where?: CustomTourRequestWhereInput
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    cursor?: CustomTourRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * Itinerary.UserFeedback
   */
  export type Itinerary$UserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * Itinerary without action
   */
  export type ItineraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
  }


  /**
   * Model ItineraryDay
   */

  export type AggregateItineraryDay = {
    _count: ItineraryDayCountAggregateOutputType | null
    _avg: ItineraryDayAvgAggregateOutputType | null
    _sum: ItineraryDaySumAggregateOutputType | null
    _min: ItineraryDayMinAggregateOutputType | null
    _max: ItineraryDayMaxAggregateOutputType | null
  }

  export type ItineraryDayAvgAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
  }

  export type ItineraryDaySumAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
  }

  export type ItineraryDayMinAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
    title: string | null
    description: string | null
    accommodation: string | null
    transportation: string | null
    notes: string | null
  }

  export type ItineraryDayMaxAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
    title: string | null
    description: string | null
    accommodation: string | null
    transportation: string | null
    notes: string | null
  }

  export type ItineraryDayCountAggregateOutputType = {
    id: number
    itineraryId: number
    dayNumber: number
    title: number
    description: number
    activities: number
    accommodation: number
    meals: number
    transportation: number
    notes: number
    _all: number
  }


  export type ItineraryDayAvgAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
  }

  export type ItineraryDaySumAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
  }

  export type ItineraryDayMinAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    accommodation?: true
    transportation?: true
    notes?: true
  }

  export type ItineraryDayMaxAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    accommodation?: true
    transportation?: true
    notes?: true
  }

  export type ItineraryDayCountAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    activities?: true
    accommodation?: true
    meals?: true
    transportation?: true
    notes?: true
    _all?: true
  }

  export type ItineraryDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItineraryDay to aggregate.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItineraryDays
    **/
    _count?: true | ItineraryDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItineraryDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryDayMaxAggregateInputType
  }

  export type GetItineraryDayAggregateType<T extends ItineraryDayAggregateArgs> = {
        [P in keyof T & keyof AggregateItineraryDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItineraryDay[P]>
      : GetScalarType<T[P], AggregateItineraryDay[P]>
  }




  export type ItineraryDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryDayWhereInput
    orderBy?: ItineraryDayOrderByWithAggregationInput | ItineraryDayOrderByWithAggregationInput[]
    by: ItineraryDayScalarFieldEnum[] | ItineraryDayScalarFieldEnum
    having?: ItineraryDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryDayCountAggregateInputType | true
    _avg?: ItineraryDayAvgAggregateInputType
    _sum?: ItineraryDaySumAggregateInputType
    _min?: ItineraryDayMinAggregateInputType
    _max?: ItineraryDayMaxAggregateInputType
  }

  export type ItineraryDayGroupByOutputType = {
    id: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities: string[]
    accommodation: string | null
    meals: string[]
    transportation: string | null
    notes: string | null
    _count: ItineraryDayCountAggregateOutputType | null
    _avg: ItineraryDayAvgAggregateOutputType | null
    _sum: ItineraryDaySumAggregateOutputType | null
    _min: ItineraryDayMinAggregateOutputType | null
    _max: ItineraryDayMaxAggregateOutputType | null
  }

  type GetItineraryDayGroupByPayload<T extends ItineraryDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryDayGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryDayGroupByOutputType[P]>
        }
      >
    >


  export type ItineraryDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itineraryDay"]>

  export type ItineraryDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itineraryDay"]>

  export type ItineraryDaySelectScalar = {
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
  }

  export type ItineraryDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }
  export type ItineraryDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }

  export type $ItineraryDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItineraryDay"
    objects: {
      itinerary: Prisma.$ItineraryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itineraryId: number
      dayNumber: number
      title: string
      description: string
      activities: string[]
      accommodation: string | null
      meals: string[]
      transportation: string | null
      notes: string | null
    }, ExtArgs["result"]["itineraryDay"]>
    composites: {}
  }

  type ItineraryDayGetPayload<S extends boolean | null | undefined | ItineraryDayDefaultArgs> = $Result.GetResult<Prisma.$ItineraryDayPayload, S>

  type ItineraryDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryDayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryDayCountAggregateInputType | true
    }

  export interface ItineraryDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItineraryDay'], meta: { name: 'ItineraryDay' } }
    /**
     * Find zero or one ItineraryDay that matches the filter.
     * @param {ItineraryDayFindUniqueArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryDayFindUniqueArgs>(args: SelectSubset<T, ItineraryDayFindUniqueArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ItineraryDay that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItineraryDayFindUniqueOrThrowArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ItineraryDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindFirstArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryDayFindFirstArgs>(args?: SelectSubset<T, ItineraryDayFindFirstArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ItineraryDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindFirstOrThrowArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ItineraryDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItineraryDays
     * const itineraryDays = await prisma.itineraryDay.findMany()
     * 
     * // Get first 10 ItineraryDays
     * const itineraryDays = await prisma.itineraryDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryDayWithIdOnly = await prisma.itineraryDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryDayFindManyArgs>(args?: SelectSubset<T, ItineraryDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ItineraryDay.
     * @param {ItineraryDayCreateArgs} args - Arguments to create a ItineraryDay.
     * @example
     * // Create one ItineraryDay
     * const ItineraryDay = await prisma.itineraryDay.create({
     *   data: {
     *     // ... data to create a ItineraryDay
     *   }
     * })
     * 
     */
    create<T extends ItineraryDayCreateArgs>(args: SelectSubset<T, ItineraryDayCreateArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ItineraryDays.
     * @param {ItineraryDayCreateManyArgs} args - Arguments to create many ItineraryDays.
     * @example
     * // Create many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryDayCreateManyArgs>(args?: SelectSubset<T, ItineraryDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItineraryDays and returns the data saved in the database.
     * @param {ItineraryDayCreateManyAndReturnArgs} args - Arguments to create many ItineraryDays.
     * @example
     * // Create many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItineraryDays and only return the `id`
     * const itineraryDayWithIdOnly = await prisma.itineraryDay.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ItineraryDay.
     * @param {ItineraryDayDeleteArgs} args - Arguments to delete one ItineraryDay.
     * @example
     * // Delete one ItineraryDay
     * const ItineraryDay = await prisma.itineraryDay.delete({
     *   where: {
     *     // ... filter to delete one ItineraryDay
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDayDeleteArgs>(args: SelectSubset<T, ItineraryDayDeleteArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ItineraryDay.
     * @param {ItineraryDayUpdateArgs} args - Arguments to update one ItineraryDay.
     * @example
     * // Update one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryDayUpdateArgs>(args: SelectSubset<T, ItineraryDayUpdateArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ItineraryDays.
     * @param {ItineraryDayDeleteManyArgs} args - Arguments to filter ItineraryDays to delete.
     * @example
     * // Delete a few ItineraryDays
     * const { count } = await prisma.itineraryDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDayDeleteManyArgs>(args?: SelectSubset<T, ItineraryDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItineraryDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryDayUpdateManyArgs>(args: SelectSubset<T, ItineraryDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItineraryDay.
     * @param {ItineraryDayUpsertArgs} args - Arguments to update or create a ItineraryDay.
     * @example
     * // Update or create a ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.upsert({
     *   create: {
     *     // ... data to create a ItineraryDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItineraryDay we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryDayUpsertArgs>(args: SelectSubset<T, ItineraryDayUpsertArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ItineraryDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayCountArgs} args - Arguments to filter ItineraryDays to count.
     * @example
     * // Count the number of ItineraryDays
     * const count = await prisma.itineraryDay.count({
     *   where: {
     *     // ... the filter for the ItineraryDays we want to count
     *   }
     * })
    **/
    count<T extends ItineraryDayCountArgs>(
      args?: Subset<T, ItineraryDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItineraryDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryDayAggregateArgs>(args: Subset<T, ItineraryDayAggregateArgs>): Prisma.PrismaPromise<GetItineraryDayAggregateType<T>>

    /**
     * Group by ItineraryDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryDayGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItineraryDay model
   */
  readonly fields: ItineraryDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItineraryDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerary<T extends ItineraryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItineraryDefaultArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItineraryDay model
   */ 
  interface ItineraryDayFieldRefs {
    readonly id: FieldRef<"ItineraryDay", 'Int'>
    readonly itineraryId: FieldRef<"ItineraryDay", 'Int'>
    readonly dayNumber: FieldRef<"ItineraryDay", 'Int'>
    readonly title: FieldRef<"ItineraryDay", 'String'>
    readonly description: FieldRef<"ItineraryDay", 'String'>
    readonly activities: FieldRef<"ItineraryDay", 'String[]'>
    readonly accommodation: FieldRef<"ItineraryDay", 'String'>
    readonly meals: FieldRef<"ItineraryDay", 'String[]'>
    readonly transportation: FieldRef<"ItineraryDay", 'String'>
    readonly notes: FieldRef<"ItineraryDay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItineraryDay findUnique
   */
  export type ItineraryDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay findUniqueOrThrow
   */
  export type ItineraryDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay findFirst
   */
  export type ItineraryDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItineraryDays.
     */
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay findFirstOrThrow
   */
  export type ItineraryDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItineraryDays.
     */
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay findMany
   */
  export type ItineraryDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDays to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay create
   */
  export type ItineraryDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ItineraryDay.
     */
    data: XOR<ItineraryDayCreateInput, ItineraryDayUncheckedCreateInput>
  }

  /**
   * ItineraryDay createMany
   */
  export type ItineraryDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItineraryDays.
     */
    data: ItineraryDayCreateManyInput | ItineraryDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItineraryDay createManyAndReturn
   */
  export type ItineraryDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ItineraryDays.
     */
    data: ItineraryDayCreateManyInput | ItineraryDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItineraryDay update
   */
  export type ItineraryDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ItineraryDay.
     */
    data: XOR<ItineraryDayUpdateInput, ItineraryDayUncheckedUpdateInput>
    /**
     * Choose, which ItineraryDay to update.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay updateMany
   */
  export type ItineraryDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItineraryDays.
     */
    data: XOR<ItineraryDayUpdateManyMutationInput, ItineraryDayUncheckedUpdateManyInput>
    /**
     * Filter which ItineraryDays to update
     */
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryDay upsert
   */
  export type ItineraryDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ItineraryDay to update in case it exists.
     */
    where: ItineraryDayWhereUniqueInput
    /**
     * In case the ItineraryDay found by the `where` argument doesn't exist, create a new ItineraryDay with this data.
     */
    create: XOR<ItineraryDayCreateInput, ItineraryDayUncheckedCreateInput>
    /**
     * In case the ItineraryDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryDayUpdateInput, ItineraryDayUncheckedUpdateInput>
  }

  /**
   * ItineraryDay delete
   */
  export type ItineraryDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter which ItineraryDay to delete.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay deleteMany
   */
  export type ItineraryDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItineraryDays to delete
     */
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryDay without action
   */
  export type ItineraryDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
  }


  /**
   * Model CustomTourRequest
   */

  export type AggregateCustomTourRequest = {
    _count: CustomTourRequestCountAggregateOutputType | null
    _avg: CustomTourRequestAvgAggregateOutputType | null
    _sum: CustomTourRequestSumAggregateOutputType | null
    _min: CustomTourRequestMinAggregateOutputType | null
    _max: CustomTourRequestMaxAggregateOutputType | null
  }

  export type CustomTourRequestAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
  }

  export type CustomTourRequestSumAggregateOutputType = {
    id: number | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
  }

  export type CustomTourRequestMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    preferredDates: string | null
    specialRequirements: string | null
    accommodationType: string | null
    transportPreference: string | null
    status: string | null
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date | null
  }

  export type CustomTourRequestMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    preferredDates: string | null
    specialRequirements: string | null
    accommodationType: string | null
    transportPreference: string | null
    status: string | null
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date | null
  }

  export type CustomTourRequestCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    duration: number
    groupSize: number
    budget: number
    interests: number
    preferredDates: number
    specialRequirements: number
    destinations: number
    accommodationType: number
    transportPreference: number
    status: number
    adminNotes: number
    estimatedPrice: number
    assignedItineraryId: number
    createdAt: number
    _all: number
  }


  export type CustomTourRequestAvgAggregateInputType = {
    id?: true
    duration?: true
    groupSize?: true
    budget?: true
    estimatedPrice?: true
    assignedItineraryId?: true
  }

  export type CustomTourRequestSumAggregateInputType = {
    id?: true
    duration?: true
    groupSize?: true
    budget?: true
    estimatedPrice?: true
    assignedItineraryId?: true
  }

  export type CustomTourRequestMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    preferredDates?: true
    specialRequirements?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
  }

  export type CustomTourRequestMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    preferredDates?: true
    specialRequirements?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
  }

  export type CustomTourRequestCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    interests?: true
    preferredDates?: true
    specialRequirements?: true
    destinations?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
    _all?: true
  }

  export type CustomTourRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourRequest to aggregate.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomTourRequests
    **/
    _count?: true | CustomTourRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomTourRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomTourRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomTourRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomTourRequestMaxAggregateInputType
  }

  export type GetCustomTourRequestAggregateType<T extends CustomTourRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomTourRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomTourRequest[P]>
      : GetScalarType<T[P], AggregateCustomTourRequest[P]>
  }




  export type CustomTourRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourRequestWhereInput
    orderBy?: CustomTourRequestOrderByWithAggregationInput | CustomTourRequestOrderByWithAggregationInput[]
    by: CustomTourRequestScalarFieldEnum[] | CustomTourRequestScalarFieldEnum
    having?: CustomTourRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomTourRequestCountAggregateInputType | true
    _avg?: CustomTourRequestAvgAggregateInputType
    _sum?: CustomTourRequestSumAggregateInputType
    _min?: CustomTourRequestMinAggregateInputType
    _max?: CustomTourRequestMaxAggregateInputType
  }

  export type CustomTourRequestGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    duration: number
    groupSize: number
    budget: number | null
    interests: string[]
    preferredDates: string | null
    specialRequirements: string | null
    destinations: string[]
    accommodationType: string | null
    transportPreference: string | null
    status: string
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date
    _count: CustomTourRequestCountAggregateOutputType | null
    _avg: CustomTourRequestAvgAggregateOutputType | null
    _sum: CustomTourRequestSumAggregateOutputType | null
    _min: CustomTourRequestMinAggregateOutputType | null
    _max: CustomTourRequestMaxAggregateOutputType | null
  }

  type GetCustomTourRequestGroupByPayload<T extends CustomTourRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomTourRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomTourRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomTourRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CustomTourRequestGroupByOutputType[P]>
        }
      >
    >


  export type CustomTourRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    interests?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }, ExtArgs["result"]["customTourRequest"]>

  export type CustomTourRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    interests?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }, ExtArgs["result"]["customTourRequest"]>

  export type CustomTourRequestSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    interests?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
  }

  export type CustomTourRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }
  export type CustomTourRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }

  export type $CustomTourRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomTourRequest"
    objects: {
      assignedItinerary: Prisma.$ItineraryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      duration: number
      groupSize: number
      budget: number | null
      interests: string[]
      preferredDates: string | null
      specialRequirements: string | null
      destinations: string[]
      accommodationType: string | null
      transportPreference: string | null
      status: string
      adminNotes: string | null
      estimatedPrice: number | null
      assignedItineraryId: number | null
      createdAt: Date
    }, ExtArgs["result"]["customTourRequest"]>
    composites: {}
  }

  type CustomTourRequestGetPayload<S extends boolean | null | undefined | CustomTourRequestDefaultArgs> = $Result.GetResult<Prisma.$CustomTourRequestPayload, S>

  type CustomTourRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomTourRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomTourRequestCountAggregateInputType | true
    }

  export interface CustomTourRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomTourRequest'], meta: { name: 'CustomTourRequest' } }
    /**
     * Find zero or one CustomTourRequest that matches the filter.
     * @param {CustomTourRequestFindUniqueArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomTourRequestFindUniqueArgs>(args: SelectSubset<T, CustomTourRequestFindUniqueArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomTourRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomTourRequestFindUniqueOrThrowArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomTourRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomTourRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomTourRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindFirstArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomTourRequestFindFirstArgs>(args?: SelectSubset<T, CustomTourRequestFindFirstArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomTourRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindFirstOrThrowArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomTourRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomTourRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomTourRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomTourRequests
     * const customTourRequests = await prisma.customTourRequest.findMany()
     * 
     * // Get first 10 CustomTourRequests
     * const customTourRequests = await prisma.customTourRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customTourRequestWithIdOnly = await prisma.customTourRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomTourRequestFindManyArgs>(args?: SelectSubset<T, CustomTourRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomTourRequest.
     * @param {CustomTourRequestCreateArgs} args - Arguments to create a CustomTourRequest.
     * @example
     * // Create one CustomTourRequest
     * const CustomTourRequest = await prisma.customTourRequest.create({
     *   data: {
     *     // ... data to create a CustomTourRequest
     *   }
     * })
     * 
     */
    create<T extends CustomTourRequestCreateArgs>(args: SelectSubset<T, CustomTourRequestCreateArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomTourRequests.
     * @param {CustomTourRequestCreateManyArgs} args - Arguments to create many CustomTourRequests.
     * @example
     * // Create many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomTourRequestCreateManyArgs>(args?: SelectSubset<T, CustomTourRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomTourRequests and returns the data saved in the database.
     * @param {CustomTourRequestCreateManyAndReturnArgs} args - Arguments to create many CustomTourRequests.
     * @example
     * // Create many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomTourRequests and only return the `id`
     * const customTourRequestWithIdOnly = await prisma.customTourRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomTourRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomTourRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomTourRequest.
     * @param {CustomTourRequestDeleteArgs} args - Arguments to delete one CustomTourRequest.
     * @example
     * // Delete one CustomTourRequest
     * const CustomTourRequest = await prisma.customTourRequest.delete({
     *   where: {
     *     // ... filter to delete one CustomTourRequest
     *   }
     * })
     * 
     */
    delete<T extends CustomTourRequestDeleteArgs>(args: SelectSubset<T, CustomTourRequestDeleteArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomTourRequest.
     * @param {CustomTourRequestUpdateArgs} args - Arguments to update one CustomTourRequest.
     * @example
     * // Update one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomTourRequestUpdateArgs>(args: SelectSubset<T, CustomTourRequestUpdateArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomTourRequests.
     * @param {CustomTourRequestDeleteManyArgs} args - Arguments to filter CustomTourRequests to delete.
     * @example
     * // Delete a few CustomTourRequests
     * const { count } = await prisma.customTourRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomTourRequestDeleteManyArgs>(args?: SelectSubset<T, CustomTourRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomTourRequestUpdateManyArgs>(args: SelectSubset<T, CustomTourRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomTourRequest.
     * @param {CustomTourRequestUpsertArgs} args - Arguments to update or create a CustomTourRequest.
     * @example
     * // Update or create a CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.upsert({
     *   create: {
     *     // ... data to create a CustomTourRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomTourRequest we want to update
     *   }
     * })
     */
    upsert<T extends CustomTourRequestUpsertArgs>(args: SelectSubset<T, CustomTourRequestUpsertArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestCountArgs} args - Arguments to filter CustomTourRequests to count.
     * @example
     * // Count the number of CustomTourRequests
     * const count = await prisma.customTourRequest.count({
     *   where: {
     *     // ... the filter for the CustomTourRequests we want to count
     *   }
     * })
    **/
    count<T extends CustomTourRequestCountArgs>(
      args?: Subset<T, CustomTourRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomTourRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomTourRequestAggregateArgs>(args: Subset<T, CustomTourRequestAggregateArgs>): Prisma.PrismaPromise<GetCustomTourRequestAggregateType<T>>

    /**
     * Group by CustomTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomTourRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomTourRequestGroupByArgs['orderBy'] }
        : { orderBy?: CustomTourRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomTourRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomTourRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomTourRequest model
   */
  readonly fields: CustomTourRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomTourRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomTourRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedItinerary<T extends CustomTourRequest$assignedItineraryArgs<ExtArgs> = {}>(args?: Subset<T, CustomTourRequest$assignedItineraryArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomTourRequest model
   */ 
  interface CustomTourRequestFieldRefs {
    readonly id: FieldRef<"CustomTourRequest", 'Int'>
    readonly firstName: FieldRef<"CustomTourRequest", 'String'>
    readonly lastName: FieldRef<"CustomTourRequest", 'String'>
    readonly email: FieldRef<"CustomTourRequest", 'String'>
    readonly phone: FieldRef<"CustomTourRequest", 'String'>
    readonly duration: FieldRef<"CustomTourRequest", 'Int'>
    readonly groupSize: FieldRef<"CustomTourRequest", 'Int'>
    readonly budget: FieldRef<"CustomTourRequest", 'Int'>
    readonly interests: FieldRef<"CustomTourRequest", 'String[]'>
    readonly preferredDates: FieldRef<"CustomTourRequest", 'String'>
    readonly specialRequirements: FieldRef<"CustomTourRequest", 'String'>
    readonly destinations: FieldRef<"CustomTourRequest", 'String[]'>
    readonly accommodationType: FieldRef<"CustomTourRequest", 'String'>
    readonly transportPreference: FieldRef<"CustomTourRequest", 'String'>
    readonly status: FieldRef<"CustomTourRequest", 'String'>
    readonly adminNotes: FieldRef<"CustomTourRequest", 'String'>
    readonly estimatedPrice: FieldRef<"CustomTourRequest", 'Int'>
    readonly assignedItineraryId: FieldRef<"CustomTourRequest", 'Int'>
    readonly createdAt: FieldRef<"CustomTourRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomTourRequest findUnique
   */
  export type CustomTourRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest findUniqueOrThrow
   */
  export type CustomTourRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest findFirst
   */
  export type CustomTourRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourRequests.
     */
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest findFirstOrThrow
   */
  export type CustomTourRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourRequests.
     */
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest findMany
   */
  export type CustomTourRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequests to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest create
   */
  export type CustomTourRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomTourRequest.
     */
    data: XOR<CustomTourRequestCreateInput, CustomTourRequestUncheckedCreateInput>
  }

  /**
   * CustomTourRequest createMany
   */
  export type CustomTourRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomTourRequests.
     */
    data: CustomTourRequestCreateManyInput | CustomTourRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomTourRequest createManyAndReturn
   */
  export type CustomTourRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomTourRequests.
     */
    data: CustomTourRequestCreateManyInput | CustomTourRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomTourRequest update
   */
  export type CustomTourRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomTourRequest.
     */
    data: XOR<CustomTourRequestUpdateInput, CustomTourRequestUncheckedUpdateInput>
    /**
     * Choose, which CustomTourRequest to update.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest updateMany
   */
  export type CustomTourRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomTourRequests.
     */
    data: XOR<CustomTourRequestUpdateManyMutationInput, CustomTourRequestUncheckedUpdateManyInput>
    /**
     * Filter which CustomTourRequests to update
     */
    where?: CustomTourRequestWhereInput
  }

  /**
   * CustomTourRequest upsert
   */
  export type CustomTourRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomTourRequest to update in case it exists.
     */
    where: CustomTourRequestWhereUniqueInput
    /**
     * In case the CustomTourRequest found by the `where` argument doesn't exist, create a new CustomTourRequest with this data.
     */
    create: XOR<CustomTourRequestCreateInput, CustomTourRequestUncheckedCreateInput>
    /**
     * In case the CustomTourRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomTourRequestUpdateInput, CustomTourRequestUncheckedUpdateInput>
  }

  /**
   * CustomTourRequest delete
   */
  export type CustomTourRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter which CustomTourRequest to delete.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest deleteMany
   */
  export type CustomTourRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourRequests to delete
     */
    where?: CustomTourRequestWhereInput
  }

  /**
   * CustomTourRequest.assignedItinerary
   */
  export type CustomTourRequest$assignedItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
  }

  /**
   * CustomTourRequest without action
   */
  export type CustomTourRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
  }


  /**
   * Model TourOperator
   */

  export type AggregateTourOperator = {
    _count: TourOperatorCountAggregateOutputType | null
    _avg: TourOperatorAvgAggregateOutputType | null
    _sum: TourOperatorSumAggregateOutputType | null
    _min: TourOperatorMinAggregateOutputType | null
    _max: TourOperatorMaxAggregateOutputType | null
  }

  export type TourOperatorAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    reviewCount: number | null
    establishedYear: number | null
  }

  export type TourOperatorSumAggregateOutputType = {
    id: number | null
    rating: number | null
    reviewCount: number | null
    establishedYear: number | null
  }

  export type TourOperatorMinAggregateOutputType = {
    id: number | null
    name: string | null
    website: string | null
    description: string | null
    bestFeature: string | null
    rating: number | null
    reviewCount: number | null
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    establishedYear: number | null
    createdAt: Date | null
  }

  export type TourOperatorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    website: string | null
    description: string | null
    bestFeature: string | null
    rating: number | null
    reviewCount: number | null
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    establishedYear: number | null
    createdAt: Date | null
  }

  export type TourOperatorCountAggregateOutputType = {
    id: number
    name: number
    website: number
    description: number
    bestFeature: number
    specialties: number
    rating: number
    reviewCount: number
    logoUrl: number
    contactEmail: number
    contactPhone: number
    isActive: number
    establishedYear: number
    certifications: number
    awards: number
    createdAt: number
    _all: number
  }


  export type TourOperatorAvgAggregateInputType = {
    id?: true
    rating?: true
    reviewCount?: true
    establishedYear?: true
  }

  export type TourOperatorSumAggregateInputType = {
    id?: true
    rating?: true
    reviewCount?: true
    establishedYear?: true
  }

  export type TourOperatorMinAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    createdAt?: true
  }

  export type TourOperatorMaxAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    createdAt?: true
  }

  export type TourOperatorCountAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    specialties?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    certifications?: true
    awards?: true
    createdAt?: true
    _all?: true
  }

  export type TourOperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourOperator to aggregate.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourOperators
    **/
    _count?: true | TourOperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourOperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourOperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourOperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourOperatorMaxAggregateInputType
  }

  export type GetTourOperatorAggregateType<T extends TourOperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateTourOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourOperator[P]>
      : GetScalarType<T[P], AggregateTourOperator[P]>
  }




  export type TourOperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourOperatorWhereInput
    orderBy?: TourOperatorOrderByWithAggregationInput | TourOperatorOrderByWithAggregationInput[]
    by: TourOperatorScalarFieldEnum[] | TourOperatorScalarFieldEnum
    having?: TourOperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourOperatorCountAggregateInputType | true
    _avg?: TourOperatorAvgAggregateInputType
    _sum?: TourOperatorSumAggregateInputType
    _min?: TourOperatorMinAggregateInputType
    _max?: TourOperatorMaxAggregateInputType
  }

  export type TourOperatorGroupByOutputType = {
    id: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties: string[]
    rating: number
    reviewCount: number
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean
    establishedYear: number | null
    certifications: string[]
    awards: string[]
    createdAt: Date
    _count: TourOperatorCountAggregateOutputType | null
    _avg: TourOperatorAvgAggregateOutputType | null
    _sum: TourOperatorSumAggregateOutputType | null
    _min: TourOperatorMinAggregateOutputType | null
    _max: TourOperatorMaxAggregateOutputType | null
  }

  type GetTourOperatorGroupByPayload<T extends TourOperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourOperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourOperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourOperatorGroupByOutputType[P]>
            : GetScalarType<T[P], TourOperatorGroupByOutputType[P]>
        }
      >
    >


  export type TourOperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
    tours?: boolean | TourOperator$toursArgs<ExtArgs>
    _count?: boolean | TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourOperator"]>

  export type TourOperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tourOperator"]>

  export type TourOperatorSelectScalar = {
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
  }

  export type TourOperatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | TourOperator$toursArgs<ExtArgs>
    _count?: boolean | TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TourOperatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TourOperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourOperator"
    objects: {
      tours: Prisma.$TourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      website: string
      description: string
      bestFeature: string
      specialties: string[]
      rating: number
      reviewCount: number
      logoUrl: string | null
      contactEmail: string | null
      contactPhone: string | null
      isActive: boolean
      establishedYear: number | null
      certifications: string[]
      awards: string[]
      createdAt: Date
    }, ExtArgs["result"]["tourOperator"]>
    composites: {}
  }

  type TourOperatorGetPayload<S extends boolean | null | undefined | TourOperatorDefaultArgs> = $Result.GetResult<Prisma.$TourOperatorPayload, S>

  type TourOperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourOperatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourOperatorCountAggregateInputType | true
    }

  export interface TourOperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourOperator'], meta: { name: 'TourOperator' } }
    /**
     * Find zero or one TourOperator that matches the filter.
     * @param {TourOperatorFindUniqueArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourOperatorFindUniqueArgs>(args: SelectSubset<T, TourOperatorFindUniqueArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourOperator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourOperatorFindUniqueOrThrowArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourOperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, TourOperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourOperator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindFirstArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourOperatorFindFirstArgs>(args?: SelectSubset<T, TourOperatorFindFirstArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourOperator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindFirstOrThrowArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourOperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, TourOperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourOperators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourOperators
     * const tourOperators = await prisma.tourOperator.findMany()
     * 
     * // Get first 10 TourOperators
     * const tourOperators = await prisma.tourOperator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourOperatorWithIdOnly = await prisma.tourOperator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourOperatorFindManyArgs>(args?: SelectSubset<T, TourOperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourOperator.
     * @param {TourOperatorCreateArgs} args - Arguments to create a TourOperator.
     * @example
     * // Create one TourOperator
     * const TourOperator = await prisma.tourOperator.create({
     *   data: {
     *     // ... data to create a TourOperator
     *   }
     * })
     * 
     */
    create<T extends TourOperatorCreateArgs>(args: SelectSubset<T, TourOperatorCreateArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourOperators.
     * @param {TourOperatorCreateManyArgs} args - Arguments to create many TourOperators.
     * @example
     * // Create many TourOperators
     * const tourOperator = await prisma.tourOperator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourOperatorCreateManyArgs>(args?: SelectSubset<T, TourOperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourOperators and returns the data saved in the database.
     * @param {TourOperatorCreateManyAndReturnArgs} args - Arguments to create many TourOperators.
     * @example
     * // Create many TourOperators
     * const tourOperator = await prisma.tourOperator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourOperators and only return the `id`
     * const tourOperatorWithIdOnly = await prisma.tourOperator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourOperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, TourOperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TourOperator.
     * @param {TourOperatorDeleteArgs} args - Arguments to delete one TourOperator.
     * @example
     * // Delete one TourOperator
     * const TourOperator = await prisma.tourOperator.delete({
     *   where: {
     *     // ... filter to delete one TourOperator
     *   }
     * })
     * 
     */
    delete<T extends TourOperatorDeleteArgs>(args: SelectSubset<T, TourOperatorDeleteArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourOperator.
     * @param {TourOperatorUpdateArgs} args - Arguments to update one TourOperator.
     * @example
     * // Update one TourOperator
     * const tourOperator = await prisma.tourOperator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourOperatorUpdateArgs>(args: SelectSubset<T, TourOperatorUpdateArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourOperators.
     * @param {TourOperatorDeleteManyArgs} args - Arguments to filter TourOperators to delete.
     * @example
     * // Delete a few TourOperators
     * const { count } = await prisma.tourOperator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourOperatorDeleteManyArgs>(args?: SelectSubset<T, TourOperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourOperators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourOperators
     * const tourOperator = await prisma.tourOperator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourOperatorUpdateManyArgs>(args: SelectSubset<T, TourOperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourOperator.
     * @param {TourOperatorUpsertArgs} args - Arguments to update or create a TourOperator.
     * @example
     * // Update or create a TourOperator
     * const tourOperator = await prisma.tourOperator.upsert({
     *   create: {
     *     // ... data to create a TourOperator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourOperator we want to update
     *   }
     * })
     */
    upsert<T extends TourOperatorUpsertArgs>(args: SelectSubset<T, TourOperatorUpsertArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TourOperators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorCountArgs} args - Arguments to filter TourOperators to count.
     * @example
     * // Count the number of TourOperators
     * const count = await prisma.tourOperator.count({
     *   where: {
     *     // ... the filter for the TourOperators we want to count
     *   }
     * })
    **/
    count<T extends TourOperatorCountArgs>(
      args?: Subset<T, TourOperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourOperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourOperator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourOperatorAggregateArgs>(args: Subset<T, TourOperatorAggregateArgs>): Prisma.PrismaPromise<GetTourOperatorAggregateType<T>>

    /**
     * Group by TourOperator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourOperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourOperatorGroupByArgs['orderBy'] }
        : { orderBy?: TourOperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourOperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourOperator model
   */
  readonly fields: TourOperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourOperator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourOperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tours<T extends TourOperator$toursArgs<ExtArgs> = {}>(args?: Subset<T, TourOperator$toursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourOperator model
   */ 
  interface TourOperatorFieldRefs {
    readonly id: FieldRef<"TourOperator", 'Int'>
    readonly name: FieldRef<"TourOperator", 'String'>
    readonly website: FieldRef<"TourOperator", 'String'>
    readonly description: FieldRef<"TourOperator", 'String'>
    readonly bestFeature: FieldRef<"TourOperator", 'String'>
    readonly specialties: FieldRef<"TourOperator", 'String[]'>
    readonly rating: FieldRef<"TourOperator", 'Float'>
    readonly reviewCount: FieldRef<"TourOperator", 'Int'>
    readonly logoUrl: FieldRef<"TourOperator", 'String'>
    readonly contactEmail: FieldRef<"TourOperator", 'String'>
    readonly contactPhone: FieldRef<"TourOperator", 'String'>
    readonly isActive: FieldRef<"TourOperator", 'Boolean'>
    readonly establishedYear: FieldRef<"TourOperator", 'Int'>
    readonly certifications: FieldRef<"TourOperator", 'String[]'>
    readonly awards: FieldRef<"TourOperator", 'String[]'>
    readonly createdAt: FieldRef<"TourOperator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TourOperator findUnique
   */
  export type TourOperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator findUniqueOrThrow
   */
  export type TourOperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator findFirst
   */
  export type TourOperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourOperators.
     */
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator findFirstOrThrow
   */
  export type TourOperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourOperators.
     */
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator findMany
   */
  export type TourOperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperators to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator create
   */
  export type TourOperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The data needed to create a TourOperator.
     */
    data: XOR<TourOperatorCreateInput, TourOperatorUncheckedCreateInput>
  }

  /**
   * TourOperator createMany
   */
  export type TourOperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourOperators.
     */
    data: TourOperatorCreateManyInput | TourOperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourOperator createManyAndReturn
   */
  export type TourOperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TourOperators.
     */
    data: TourOperatorCreateManyInput | TourOperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourOperator update
   */
  export type TourOperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The data needed to update a TourOperator.
     */
    data: XOR<TourOperatorUpdateInput, TourOperatorUncheckedUpdateInput>
    /**
     * Choose, which TourOperator to update.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator updateMany
   */
  export type TourOperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourOperators.
     */
    data: XOR<TourOperatorUpdateManyMutationInput, TourOperatorUncheckedUpdateManyInput>
    /**
     * Filter which TourOperators to update
     */
    where?: TourOperatorWhereInput
  }

  /**
   * TourOperator upsert
   */
  export type TourOperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The filter to search for the TourOperator to update in case it exists.
     */
    where: TourOperatorWhereUniqueInput
    /**
     * In case the TourOperator found by the `where` argument doesn't exist, create a new TourOperator with this data.
     */
    create: XOR<TourOperatorCreateInput, TourOperatorUncheckedCreateInput>
    /**
     * In case the TourOperator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourOperatorUpdateInput, TourOperatorUncheckedUpdateInput>
  }

  /**
   * TourOperator delete
   */
  export type TourOperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter which TourOperator to delete.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator deleteMany
   */
  export type TourOperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourOperators to delete
     */
    where?: TourOperatorWhereInput
  }

  /**
   * TourOperator.tours
   */
  export type TourOperator$toursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * TourOperator without action
   */
  export type TourOperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
  }


  /**
   * Model Festival
   */

  export type AggregateFestival = {
    _count: FestivalCountAggregateOutputType | null
    _avg: FestivalAvgAggregateOutputType | null
    _sum: FestivalSumAggregateOutputType | null
    _min: FestivalMinAggregateOutputType | null
    _max: FestivalMaxAggregateOutputType | null
  }

  export type FestivalAvgAggregateOutputType = {
    id: number | null
    ticketPrice: number | null
    maxCapacity: number | null
  }

  export type FestivalSumAggregateOutputType = {
    id: number | null
    ticketPrice: number | null
    maxCapacity: number | null
  }

  export type FestivalMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    imageUrl: string | null
    category: string | null
    isActive: boolean | null
    ticketPrice: number | null
    maxCapacity: number | null
    createdAt: Date | null
  }

  export type FestivalMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    imageUrl: string | null
    category: string | null
    isActive: boolean | null
    ticketPrice: number | null
    maxCapacity: number | null
    createdAt: Date | null
  }

  export type FestivalCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    startDate: number
    endDate: number
    imageUrl: number
    category: number
    highlights: number
    isActive: number
    ticketPrice: number
    maxCapacity: number
    createdAt: number
    _all: number
  }


  export type FestivalAvgAggregateInputType = {
    id?: true
    ticketPrice?: true
    maxCapacity?: true
  }

  export type FestivalSumAggregateInputType = {
    id?: true
    ticketPrice?: true
    maxCapacity?: true
  }

  export type FestivalMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    imageUrl?: true
    category?: true
    isActive?: true
    ticketPrice?: true
    maxCapacity?: true
    createdAt?: true
  }

  export type FestivalMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    imageUrl?: true
    category?: true
    isActive?: true
    ticketPrice?: true
    maxCapacity?: true
    createdAt?: true
  }

  export type FestivalCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    imageUrl?: true
    category?: true
    highlights?: true
    isActive?: true
    ticketPrice?: true
    maxCapacity?: true
    createdAt?: true
    _all?: true
  }

  export type FestivalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Festival to aggregate.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Festivals
    **/
    _count?: true | FestivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FestivalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FestivalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FestivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FestivalMaxAggregateInputType
  }

  export type GetFestivalAggregateType<T extends FestivalAggregateArgs> = {
        [P in keyof T & keyof AggregateFestival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFestival[P]>
      : GetScalarType<T[P], AggregateFestival[P]>
  }




  export type FestivalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalWhereInput
    orderBy?: FestivalOrderByWithAggregationInput | FestivalOrderByWithAggregationInput[]
    by: FestivalScalarFieldEnum[] | FestivalScalarFieldEnum
    having?: FestivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FestivalCountAggregateInputType | true
    _avg?: FestivalAvgAggregateInputType
    _sum?: FestivalSumAggregateInputType
    _min?: FestivalMinAggregateInputType
    _max?: FestivalMaxAggregateInputType
  }

  export type FestivalGroupByOutputType = {
    id: number
    name: string
    description: string
    location: string
    startDate: Date
    endDate: Date
    imageUrl: string
    category: string
    highlights: string[]
    isActive: boolean
    ticketPrice: number | null
    maxCapacity: number | null
    createdAt: Date
    _count: FestivalCountAggregateOutputType | null
    _avg: FestivalAvgAggregateOutputType | null
    _sum: FestivalSumAggregateOutputType | null
    _min: FestivalMinAggregateOutputType | null
    _max: FestivalMaxAggregateOutputType | null
  }

  type GetFestivalGroupByPayload<T extends FestivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FestivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FestivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FestivalGroupByOutputType[P]>
            : GetScalarType<T[P], FestivalGroupByOutputType[P]>
        }
      >
    >


  export type FestivalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    imageUrl?: boolean
    category?: boolean
    highlights?: boolean
    isActive?: boolean
    ticketPrice?: boolean
    maxCapacity?: boolean
    createdAt?: boolean
    bookings?: boolean | Festival$bookingsArgs<ExtArgs>
    _count?: boolean | FestivalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festival"]>

  export type FestivalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    imageUrl?: boolean
    category?: boolean
    highlights?: boolean
    isActive?: boolean
    ticketPrice?: boolean
    maxCapacity?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["festival"]>

  export type FestivalSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    imageUrl?: boolean
    category?: boolean
    highlights?: boolean
    isActive?: boolean
    ticketPrice?: boolean
    maxCapacity?: boolean
    createdAt?: boolean
  }

  export type FestivalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Festival$bookingsArgs<ExtArgs>
    _count?: boolean | FestivalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FestivalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FestivalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Festival"
    objects: {
      bookings: Prisma.$FestivalBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      location: string
      startDate: Date
      endDate: Date
      imageUrl: string
      category: string
      highlights: string[]
      isActive: boolean
      ticketPrice: number | null
      maxCapacity: number | null
      createdAt: Date
    }, ExtArgs["result"]["festival"]>
    composites: {}
  }

  type FestivalGetPayload<S extends boolean | null | undefined | FestivalDefaultArgs> = $Result.GetResult<Prisma.$FestivalPayload, S>

  type FestivalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FestivalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FestivalCountAggregateInputType | true
    }

  export interface FestivalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Festival'], meta: { name: 'Festival' } }
    /**
     * Find zero or one Festival that matches the filter.
     * @param {FestivalFindUniqueArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FestivalFindUniqueArgs>(args: SelectSubset<T, FestivalFindUniqueArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Festival that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FestivalFindUniqueOrThrowArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FestivalFindUniqueOrThrowArgs>(args: SelectSubset<T, FestivalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Festival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindFirstArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FestivalFindFirstArgs>(args?: SelectSubset<T, FestivalFindFirstArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Festival that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindFirstOrThrowArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FestivalFindFirstOrThrowArgs>(args?: SelectSubset<T, FestivalFindFirstOrThrowArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Festivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Festivals
     * const festivals = await prisma.festival.findMany()
     * 
     * // Get first 10 Festivals
     * const festivals = await prisma.festival.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const festivalWithIdOnly = await prisma.festival.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FestivalFindManyArgs>(args?: SelectSubset<T, FestivalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Festival.
     * @param {FestivalCreateArgs} args - Arguments to create a Festival.
     * @example
     * // Create one Festival
     * const Festival = await prisma.festival.create({
     *   data: {
     *     // ... data to create a Festival
     *   }
     * })
     * 
     */
    create<T extends FestivalCreateArgs>(args: SelectSubset<T, FestivalCreateArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Festivals.
     * @param {FestivalCreateManyArgs} args - Arguments to create many Festivals.
     * @example
     * // Create many Festivals
     * const festival = await prisma.festival.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FestivalCreateManyArgs>(args?: SelectSubset<T, FestivalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Festivals and returns the data saved in the database.
     * @param {FestivalCreateManyAndReturnArgs} args - Arguments to create many Festivals.
     * @example
     * // Create many Festivals
     * const festival = await prisma.festival.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Festivals and only return the `id`
     * const festivalWithIdOnly = await prisma.festival.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FestivalCreateManyAndReturnArgs>(args?: SelectSubset<T, FestivalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Festival.
     * @param {FestivalDeleteArgs} args - Arguments to delete one Festival.
     * @example
     * // Delete one Festival
     * const Festival = await prisma.festival.delete({
     *   where: {
     *     // ... filter to delete one Festival
     *   }
     * })
     * 
     */
    delete<T extends FestivalDeleteArgs>(args: SelectSubset<T, FestivalDeleteArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Festival.
     * @param {FestivalUpdateArgs} args - Arguments to update one Festival.
     * @example
     * // Update one Festival
     * const festival = await prisma.festival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FestivalUpdateArgs>(args: SelectSubset<T, FestivalUpdateArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Festivals.
     * @param {FestivalDeleteManyArgs} args - Arguments to filter Festivals to delete.
     * @example
     * // Delete a few Festivals
     * const { count } = await prisma.festival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FestivalDeleteManyArgs>(args?: SelectSubset<T, FestivalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Festivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Festivals
     * const festival = await prisma.festival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FestivalUpdateManyArgs>(args: SelectSubset<T, FestivalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Festival.
     * @param {FestivalUpsertArgs} args - Arguments to update or create a Festival.
     * @example
     * // Update or create a Festival
     * const festival = await prisma.festival.upsert({
     *   create: {
     *     // ... data to create a Festival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Festival we want to update
     *   }
     * })
     */
    upsert<T extends FestivalUpsertArgs>(args: SelectSubset<T, FestivalUpsertArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Festivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalCountArgs} args - Arguments to filter Festivals to count.
     * @example
     * // Count the number of Festivals
     * const count = await prisma.festival.count({
     *   where: {
     *     // ... the filter for the Festivals we want to count
     *   }
     * })
    **/
    count<T extends FestivalCountArgs>(
      args?: Subset<T, FestivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FestivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Festival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FestivalAggregateArgs>(args: Subset<T, FestivalAggregateArgs>): Prisma.PrismaPromise<GetFestivalAggregateType<T>>

    /**
     * Group by Festival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FestivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FestivalGroupByArgs['orderBy'] }
        : { orderBy?: FestivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FestivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFestivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Festival model
   */
  readonly fields: FestivalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Festival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FestivalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Festival$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Festival$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Festival model
   */ 
  interface FestivalFieldRefs {
    readonly id: FieldRef<"Festival", 'Int'>
    readonly name: FieldRef<"Festival", 'String'>
    readonly description: FieldRef<"Festival", 'String'>
    readonly location: FieldRef<"Festival", 'String'>
    readonly startDate: FieldRef<"Festival", 'DateTime'>
    readonly endDate: FieldRef<"Festival", 'DateTime'>
    readonly imageUrl: FieldRef<"Festival", 'String'>
    readonly category: FieldRef<"Festival", 'String'>
    readonly highlights: FieldRef<"Festival", 'String[]'>
    readonly isActive: FieldRef<"Festival", 'Boolean'>
    readonly ticketPrice: FieldRef<"Festival", 'Int'>
    readonly maxCapacity: FieldRef<"Festival", 'Int'>
    readonly createdAt: FieldRef<"Festival", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Festival findUnique
   */
  export type FestivalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival findUniqueOrThrow
   */
  export type FestivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival findFirst
   */
  export type FestivalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Festivals.
     */
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival findFirstOrThrow
   */
  export type FestivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Festivals.
     */
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival findMany
   */
  export type FestivalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festivals to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival create
   */
  export type FestivalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The data needed to create a Festival.
     */
    data: XOR<FestivalCreateInput, FestivalUncheckedCreateInput>
  }

  /**
   * Festival createMany
   */
  export type FestivalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Festivals.
     */
    data: FestivalCreateManyInput | FestivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Festival createManyAndReturn
   */
  export type FestivalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Festivals.
     */
    data: FestivalCreateManyInput | FestivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Festival update
   */
  export type FestivalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The data needed to update a Festival.
     */
    data: XOR<FestivalUpdateInput, FestivalUncheckedUpdateInput>
    /**
     * Choose, which Festival to update.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival updateMany
   */
  export type FestivalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Festivals.
     */
    data: XOR<FestivalUpdateManyMutationInput, FestivalUncheckedUpdateManyInput>
    /**
     * Filter which Festivals to update
     */
    where?: FestivalWhereInput
  }

  /**
   * Festival upsert
   */
  export type FestivalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The filter to search for the Festival to update in case it exists.
     */
    where: FestivalWhereUniqueInput
    /**
     * In case the Festival found by the `where` argument doesn't exist, create a new Festival with this data.
     */
    create: XOR<FestivalCreateInput, FestivalUncheckedCreateInput>
    /**
     * In case the Festival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FestivalUpdateInput, FestivalUncheckedUpdateInput>
  }

  /**
   * Festival delete
   */
  export type FestivalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter which Festival to delete.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival deleteMany
   */
  export type FestivalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Festivals to delete
     */
    where?: FestivalWhereInput
  }

  /**
   * Festival.bookings
   */
  export type Festival$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    where?: FestivalBookingWhereInput
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    cursor?: FestivalBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * Festival without action
   */
  export type FestivalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
  }


  /**
   * Model FestivalBooking
   */

  export type AggregateFestivalBooking = {
    _count: FestivalBookingCountAggregateOutputType | null
    _avg: FestivalBookingAvgAggregateOutputType | null
    _sum: FestivalBookingSumAggregateOutputType | null
    _min: FestivalBookingMinAggregateOutputType | null
    _max: FestivalBookingMaxAggregateOutputType | null
  }

  export type FestivalBookingAvgAggregateOutputType = {
    id: number | null
    festivalId: number | null
    numberOfTickets: number | null
    totalAmount: number | null
  }

  export type FestivalBookingSumAggregateOutputType = {
    id: number | null
    festivalId: number | null
    numberOfTickets: number | null
    totalAmount: number | null
  }

  export type FestivalBookingMinAggregateOutputType = {
    id: number | null
    festivalId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    numberOfTickets: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FestivalBookingMaxAggregateOutputType = {
    id: number | null
    festivalId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    numberOfTickets: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FestivalBookingCountAggregateOutputType = {
    id: number
    festivalId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    numberOfTickets: number
    totalAmount: number
    specialRequests: number
    status: number
    createdAt: number
    _all: number
  }


  export type FestivalBookingAvgAggregateInputType = {
    id?: true
    festivalId?: true
    numberOfTickets?: true
    totalAmount?: true
  }

  export type FestivalBookingSumAggregateInputType = {
    id?: true
    festivalId?: true
    numberOfTickets?: true
    totalAmount?: true
  }

  export type FestivalBookingMinAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type FestivalBookingMaxAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type FestivalBookingCountAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FestivalBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FestivalBooking to aggregate.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FestivalBookings
    **/
    _count?: true | FestivalBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FestivalBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FestivalBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FestivalBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FestivalBookingMaxAggregateInputType
  }

  export type GetFestivalBookingAggregateType<T extends FestivalBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateFestivalBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFestivalBooking[P]>
      : GetScalarType<T[P], AggregateFestivalBooking[P]>
  }




  export type FestivalBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalBookingWhereInput
    orderBy?: FestivalBookingOrderByWithAggregationInput | FestivalBookingOrderByWithAggregationInput[]
    by: FestivalBookingScalarFieldEnum[] | FestivalBookingScalarFieldEnum
    having?: FestivalBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FestivalBookingCountAggregateInputType | true
    _avg?: FestivalBookingAvgAggregateInputType
    _sum?: FestivalBookingSumAggregateInputType
    _min?: FestivalBookingMinAggregateInputType
    _max?: FestivalBookingMaxAggregateInputType
  }

  export type FestivalBookingGroupByOutputType = {
    id: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests: string | null
    status: string
    createdAt: Date
    _count: FestivalBookingCountAggregateOutputType | null
    _avg: FestivalBookingAvgAggregateOutputType | null
    _sum: FestivalBookingSumAggregateOutputType | null
    _min: FestivalBookingMinAggregateOutputType | null
    _max: FestivalBookingMaxAggregateOutputType | null
  }

  type GetFestivalBookingGroupByPayload<T extends FestivalBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FestivalBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FestivalBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FestivalBookingGroupByOutputType[P]>
            : GetScalarType<T[P], FestivalBookingGroupByOutputType[P]>
        }
      >
    >


  export type FestivalBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festivalBooking"]>

  export type FestivalBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festivalBooking"]>

  export type FestivalBookingSelectScalar = {
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FestivalBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }
  export type FestivalBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }

  export type $FestivalBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FestivalBooking"
    objects: {
      festival: Prisma.$FestivalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      festivalId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      numberOfTickets: number
      totalAmount: number
      specialRequests: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["festivalBooking"]>
    composites: {}
  }

  type FestivalBookingGetPayload<S extends boolean | null | undefined | FestivalBookingDefaultArgs> = $Result.GetResult<Prisma.$FestivalBookingPayload, S>

  type FestivalBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FestivalBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FestivalBookingCountAggregateInputType | true
    }

  export interface FestivalBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FestivalBooking'], meta: { name: 'FestivalBooking' } }
    /**
     * Find zero or one FestivalBooking that matches the filter.
     * @param {FestivalBookingFindUniqueArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FestivalBookingFindUniqueArgs>(args: SelectSubset<T, FestivalBookingFindUniqueArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FestivalBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FestivalBookingFindUniqueOrThrowArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FestivalBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, FestivalBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FestivalBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindFirstArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FestivalBookingFindFirstArgs>(args?: SelectSubset<T, FestivalBookingFindFirstArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FestivalBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindFirstOrThrowArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FestivalBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, FestivalBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FestivalBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FestivalBookings
     * const festivalBookings = await prisma.festivalBooking.findMany()
     * 
     * // Get first 10 FestivalBookings
     * const festivalBookings = await prisma.festivalBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const festivalBookingWithIdOnly = await prisma.festivalBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FestivalBookingFindManyArgs>(args?: SelectSubset<T, FestivalBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FestivalBooking.
     * @param {FestivalBookingCreateArgs} args - Arguments to create a FestivalBooking.
     * @example
     * // Create one FestivalBooking
     * const FestivalBooking = await prisma.festivalBooking.create({
     *   data: {
     *     // ... data to create a FestivalBooking
     *   }
     * })
     * 
     */
    create<T extends FestivalBookingCreateArgs>(args: SelectSubset<T, FestivalBookingCreateArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FestivalBookings.
     * @param {FestivalBookingCreateManyArgs} args - Arguments to create many FestivalBookings.
     * @example
     * // Create many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FestivalBookingCreateManyArgs>(args?: SelectSubset<T, FestivalBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FestivalBookings and returns the data saved in the database.
     * @param {FestivalBookingCreateManyAndReturnArgs} args - Arguments to create many FestivalBookings.
     * @example
     * // Create many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FestivalBookings and only return the `id`
     * const festivalBookingWithIdOnly = await prisma.festivalBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FestivalBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, FestivalBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FestivalBooking.
     * @param {FestivalBookingDeleteArgs} args - Arguments to delete one FestivalBooking.
     * @example
     * // Delete one FestivalBooking
     * const FestivalBooking = await prisma.festivalBooking.delete({
     *   where: {
     *     // ... filter to delete one FestivalBooking
     *   }
     * })
     * 
     */
    delete<T extends FestivalBookingDeleteArgs>(args: SelectSubset<T, FestivalBookingDeleteArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FestivalBooking.
     * @param {FestivalBookingUpdateArgs} args - Arguments to update one FestivalBooking.
     * @example
     * // Update one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FestivalBookingUpdateArgs>(args: SelectSubset<T, FestivalBookingUpdateArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FestivalBookings.
     * @param {FestivalBookingDeleteManyArgs} args - Arguments to filter FestivalBookings to delete.
     * @example
     * // Delete a few FestivalBookings
     * const { count } = await prisma.festivalBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FestivalBookingDeleteManyArgs>(args?: SelectSubset<T, FestivalBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FestivalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FestivalBookingUpdateManyArgs>(args: SelectSubset<T, FestivalBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FestivalBooking.
     * @param {FestivalBookingUpsertArgs} args - Arguments to update or create a FestivalBooking.
     * @example
     * // Update or create a FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.upsert({
     *   create: {
     *     // ... data to create a FestivalBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FestivalBooking we want to update
     *   }
     * })
     */
    upsert<T extends FestivalBookingUpsertArgs>(args: SelectSubset<T, FestivalBookingUpsertArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FestivalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingCountArgs} args - Arguments to filter FestivalBookings to count.
     * @example
     * // Count the number of FestivalBookings
     * const count = await prisma.festivalBooking.count({
     *   where: {
     *     // ... the filter for the FestivalBookings we want to count
     *   }
     * })
    **/
    count<T extends FestivalBookingCountArgs>(
      args?: Subset<T, FestivalBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FestivalBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FestivalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FestivalBookingAggregateArgs>(args: Subset<T, FestivalBookingAggregateArgs>): Prisma.PrismaPromise<GetFestivalBookingAggregateType<T>>

    /**
     * Group by FestivalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FestivalBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FestivalBookingGroupByArgs['orderBy'] }
        : { orderBy?: FestivalBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FestivalBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFestivalBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FestivalBooking model
   */
  readonly fields: FestivalBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FestivalBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FestivalBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    festival<T extends FestivalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FestivalDefaultArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FestivalBooking model
   */ 
  interface FestivalBookingFieldRefs {
    readonly id: FieldRef<"FestivalBooking", 'Int'>
    readonly festivalId: FieldRef<"FestivalBooking", 'Int'>
    readonly firstName: FieldRef<"FestivalBooking", 'String'>
    readonly lastName: FieldRef<"FestivalBooking", 'String'>
    readonly email: FieldRef<"FestivalBooking", 'String'>
    readonly phone: FieldRef<"FestivalBooking", 'String'>
    readonly numberOfTickets: FieldRef<"FestivalBooking", 'Int'>
    readonly totalAmount: FieldRef<"FestivalBooking", 'Int'>
    readonly specialRequests: FieldRef<"FestivalBooking", 'String'>
    readonly status: FieldRef<"FestivalBooking", 'String'>
    readonly createdAt: FieldRef<"FestivalBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FestivalBooking findUnique
   */
  export type FestivalBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking findUniqueOrThrow
   */
  export type FestivalBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking findFirst
   */
  export type FestivalBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FestivalBookings.
     */
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking findFirstOrThrow
   */
  export type FestivalBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FestivalBookings.
     */
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking findMany
   */
  export type FestivalBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBookings to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking create
   */
  export type FestivalBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a FestivalBooking.
     */
    data: XOR<FestivalBookingCreateInput, FestivalBookingUncheckedCreateInput>
  }

  /**
   * FestivalBooking createMany
   */
  export type FestivalBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FestivalBookings.
     */
    data: FestivalBookingCreateManyInput | FestivalBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FestivalBooking createManyAndReturn
   */
  export type FestivalBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FestivalBookings.
     */
    data: FestivalBookingCreateManyInput | FestivalBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FestivalBooking update
   */
  export type FestivalBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a FestivalBooking.
     */
    data: XOR<FestivalBookingUpdateInput, FestivalBookingUncheckedUpdateInput>
    /**
     * Choose, which FestivalBooking to update.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking updateMany
   */
  export type FestivalBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FestivalBookings.
     */
    data: XOR<FestivalBookingUpdateManyMutationInput, FestivalBookingUncheckedUpdateManyInput>
    /**
     * Filter which FestivalBookings to update
     */
    where?: FestivalBookingWhereInput
  }

  /**
   * FestivalBooking upsert
   */
  export type FestivalBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the FestivalBooking to update in case it exists.
     */
    where: FestivalBookingWhereUniqueInput
    /**
     * In case the FestivalBooking found by the `where` argument doesn't exist, create a new FestivalBooking with this data.
     */
    create: XOR<FestivalBookingCreateInput, FestivalBookingUncheckedCreateInput>
    /**
     * In case the FestivalBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FestivalBookingUpdateInput, FestivalBookingUncheckedUpdateInput>
  }

  /**
   * FestivalBooking delete
   */
  export type FestivalBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter which FestivalBooking to delete.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking deleteMany
   */
  export type FestivalBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FestivalBookings to delete
     */
    where?: FestivalBookingWhereInput
  }

  /**
   * FestivalBooking without action
   */
  export type FestivalBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
  }


  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    id: number | null
    starRating: number | null
    pricePerNight: number | null
  }

  export type HotelSumAggregateOutputType = {
    id: number | null
    starRating: number | null
    pricePerNight: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    address: string | null
    imageUrl: string | null
    category: string | null
    starRating: number | null
    pricePerNight: number | null
    isActive: boolean | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    address: string | null
    imageUrl: string | null
    category: string | null
    starRating: number | null
    pricePerNight: number | null
    isActive: boolean | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    address: number
    imageUrl: number
    images: number
    category: number
    starRating: number
    amenities: number
    features: number
    pricePerNight: number
    isActive: number
    contactEmail: number
    contactPhone: number
    website: number
    checkInTime: number
    checkOutTime: number
    cancellationPolicy: number
    createdAt: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    id?: true
    starRating?: true
    pricePerNight?: true
  }

  export type HotelSumAggregateInputType = {
    id?: true
    starRating?: true
    pricePerNight?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    category?: true
    starRating?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    category?: true
    starRating?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    images?: true
    category?: true
    starRating?: true
    amenities?: true
    features?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images: string[]
    category: string
    starRating: number
    amenities: string[]
    features: string[]
    pricePerNight: number
    isActive: boolean
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string
    checkOutTime: string
    cancellationPolicy: string | null
    createdAt: Date
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    category?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    category?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    category?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
  }

  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      rooms: Prisma.$HotelRoomPayload<ExtArgs>[]
      bookings: Prisma.$HotelBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      location: string
      address: string
      imageUrl: string
      images: string[]
      category: string
      starRating: number
      amenities: string[]
      features: string[]
      pricePerNight: number
      isActive: boolean
      contactEmail: string | null
      contactPhone: string | null
      website: string | null
      checkInTime: string
      checkOutTime: string
      cancellationPolicy: string | null
      createdAt: Date
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Hotel$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Hotel$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */ 
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'Int'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly description: FieldRef<"Hotel", 'String'>
    readonly location: FieldRef<"Hotel", 'String'>
    readonly address: FieldRef<"Hotel", 'String'>
    readonly imageUrl: FieldRef<"Hotel", 'String'>
    readonly images: FieldRef<"Hotel", 'String[]'>
    readonly category: FieldRef<"Hotel", 'String'>
    readonly starRating: FieldRef<"Hotel", 'Int'>
    readonly amenities: FieldRef<"Hotel", 'String[]'>
    readonly features: FieldRef<"Hotel", 'String[]'>
    readonly pricePerNight: FieldRef<"Hotel", 'Int'>
    readonly isActive: FieldRef<"Hotel", 'Boolean'>
    readonly contactEmail: FieldRef<"Hotel", 'String'>
    readonly contactPhone: FieldRef<"Hotel", 'String'>
    readonly website: FieldRef<"Hotel", 'String'>
    readonly checkInTime: FieldRef<"Hotel", 'String'>
    readonly checkOutTime: FieldRef<"Hotel", 'String'>
    readonly cancellationPolicy: FieldRef<"Hotel", 'String'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel.rooms
   */
  export type Hotel$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    where?: HotelRoomWhereInput
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    cursor?: HotelRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * Hotel.bookings
   */
  export type Hotel$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model HotelRoom
   */

  export type AggregateHotelRoom = {
    _count: HotelRoomCountAggregateOutputType | null
    _avg: HotelRoomAvgAggregateOutputType | null
    _sum: HotelRoomSumAggregateOutputType | null
    _min: HotelRoomMinAggregateOutputType | null
    _max: HotelRoomMaxAggregateOutputType | null
  }

  export type HotelRoomAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxOccupancy: number | null
    pricePerNight: number | null
    totalRooms: number | null
  }

  export type HotelRoomSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxOccupancy: number | null
    pricePerNight: number | null
    totalRooms: number | null
  }

  export type HotelRoomMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomType: string | null
    roomName: string | null
    description: string | null
    imageUrl: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    pricePerNight: number | null
    totalRooms: number | null
    isActive: boolean | null
  }

  export type HotelRoomMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomType: string | null
    roomName: string | null
    description: string | null
    imageUrl: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    pricePerNight: number | null
    totalRooms: number | null
    isActive: boolean | null
  }

  export type HotelRoomCountAggregateOutputType = {
    id: number
    hotelId: number
    roomType: number
    roomName: number
    description: number
    imageUrl: number
    images: number
    maxOccupancy: number
    bedType: number
    roomSize: number
    amenities: number
    pricePerNight: number
    totalRooms: number
    isActive: number
    _all: number
  }


  export type HotelRoomAvgAggregateInputType = {
    id?: true
    hotelId?: true
    maxOccupancy?: true
    pricePerNight?: true
    totalRooms?: true
  }

  export type HotelRoomSumAggregateInputType = {
    id?: true
    hotelId?: true
    maxOccupancy?: true
    pricePerNight?: true
    totalRooms?: true
  }

  export type HotelRoomMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
  }

  export type HotelRoomMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
  }

  export type HotelRoomCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    images?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    amenities?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
    _all?: true
  }

  export type HotelRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRoom to aggregate.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelRooms
    **/
    _count?: true | HotelRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelRoomMaxAggregateInputType
  }

  export type GetHotelRoomAggregateType<T extends HotelRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelRoom[P]>
      : GetScalarType<T[P], AggregateHotelRoom[P]>
  }




  export type HotelRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRoomWhereInput
    orderBy?: HotelRoomOrderByWithAggregationInput | HotelRoomOrderByWithAggregationInput[]
    by: HotelRoomScalarFieldEnum[] | HotelRoomScalarFieldEnum
    having?: HotelRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelRoomCountAggregateInputType | true
    _avg?: HotelRoomAvgAggregateInputType
    _sum?: HotelRoomSumAggregateInputType
    _min?: HotelRoomMinAggregateInputType
    _max?: HotelRoomMaxAggregateInputType
  }

  export type HotelRoomGroupByOutputType = {
    id: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images: string[]
    maxOccupancy: number
    bedType: string
    roomSize: string | null
    amenities: string[]
    pricePerNight: number
    totalRooms: number
    isActive: boolean
    _count: HotelRoomCountAggregateOutputType | null
    _avg: HotelRoomAvgAggregateOutputType | null
    _sum: HotelRoomSumAggregateOutputType | null
    _min: HotelRoomMinAggregateOutputType | null
    _max: HotelRoomMaxAggregateOutputType | null
  }

  type GetHotelRoomGroupByPayload<T extends HotelRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelRoomGroupByOutputType[P]>
            : GetScalarType<T[P], HotelRoomGroupByOutputType[P]>
        }
      >
    >


  export type HotelRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    bookings?: boolean | HotelRoom$bookingsArgs<ExtArgs>
    _count?: boolean | HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRoom"]>

  export type HotelRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRoom"]>

  export type HotelRoomSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
  }

  export type HotelRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    bookings?: boolean | HotelRoom$bookingsArgs<ExtArgs>
    _count?: boolean | HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $HotelRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelRoom"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      bookings: Prisma.$HotelBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      roomType: string
      roomName: string
      description: string
      imageUrl: string
      images: string[]
      maxOccupancy: number
      bedType: string
      roomSize: string | null
      amenities: string[]
      pricePerNight: number
      totalRooms: number
      isActive: boolean
    }, ExtArgs["result"]["hotelRoom"]>
    composites: {}
  }

  type HotelRoomGetPayload<S extends boolean | null | undefined | HotelRoomDefaultArgs> = $Result.GetResult<Prisma.$HotelRoomPayload, S>

  type HotelRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelRoomCountAggregateInputType | true
    }

  export interface HotelRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelRoom'], meta: { name: 'HotelRoom' } }
    /**
     * Find zero or one HotelRoom that matches the filter.
     * @param {HotelRoomFindUniqueArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelRoomFindUniqueArgs>(args: SelectSubset<T, HotelRoomFindUniqueArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelRoomFindUniqueOrThrowArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindFirstArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelRoomFindFirstArgs>(args?: SelectSubset<T, HotelRoomFindFirstArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindFirstOrThrowArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelRooms
     * const hotelRooms = await prisma.hotelRoom.findMany()
     * 
     * // Get first 10 HotelRooms
     * const hotelRooms = await prisma.hotelRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelRoomWithIdOnly = await prisma.hotelRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelRoomFindManyArgs>(args?: SelectSubset<T, HotelRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelRoom.
     * @param {HotelRoomCreateArgs} args - Arguments to create a HotelRoom.
     * @example
     * // Create one HotelRoom
     * const HotelRoom = await prisma.hotelRoom.create({
     *   data: {
     *     // ... data to create a HotelRoom
     *   }
     * })
     * 
     */
    create<T extends HotelRoomCreateArgs>(args: SelectSubset<T, HotelRoomCreateArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelRooms.
     * @param {HotelRoomCreateManyArgs} args - Arguments to create many HotelRooms.
     * @example
     * // Create many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelRoomCreateManyArgs>(args?: SelectSubset<T, HotelRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelRooms and returns the data saved in the database.
     * @param {HotelRoomCreateManyAndReturnArgs} args - Arguments to create many HotelRooms.
     * @example
     * // Create many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelRooms and only return the `id`
     * const hotelRoomWithIdOnly = await prisma.hotelRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelRoom.
     * @param {HotelRoomDeleteArgs} args - Arguments to delete one HotelRoom.
     * @example
     * // Delete one HotelRoom
     * const HotelRoom = await prisma.hotelRoom.delete({
     *   where: {
     *     // ... filter to delete one HotelRoom
     *   }
     * })
     * 
     */
    delete<T extends HotelRoomDeleteArgs>(args: SelectSubset<T, HotelRoomDeleteArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelRoom.
     * @param {HotelRoomUpdateArgs} args - Arguments to update one HotelRoom.
     * @example
     * // Update one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelRoomUpdateArgs>(args: SelectSubset<T, HotelRoomUpdateArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelRooms.
     * @param {HotelRoomDeleteManyArgs} args - Arguments to filter HotelRooms to delete.
     * @example
     * // Delete a few HotelRooms
     * const { count } = await prisma.hotelRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelRoomDeleteManyArgs>(args?: SelectSubset<T, HotelRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelRoomUpdateManyArgs>(args: SelectSubset<T, HotelRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelRoom.
     * @param {HotelRoomUpsertArgs} args - Arguments to update or create a HotelRoom.
     * @example
     * // Update or create a HotelRoom
     * const hotelRoom = await prisma.hotelRoom.upsert({
     *   create: {
     *     // ... data to create a HotelRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelRoom we want to update
     *   }
     * })
     */
    upsert<T extends HotelRoomUpsertArgs>(args: SelectSubset<T, HotelRoomUpsertArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomCountArgs} args - Arguments to filter HotelRooms to count.
     * @example
     * // Count the number of HotelRooms
     * const count = await prisma.hotelRoom.count({
     *   where: {
     *     // ... the filter for the HotelRooms we want to count
     *   }
     * })
    **/
    count<T extends HotelRoomCountArgs>(
      args?: Subset<T, HotelRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelRoomAggregateArgs>(args: Subset<T, HotelRoomAggregateArgs>): Prisma.PrismaPromise<GetHotelRoomAggregateType<T>>

    /**
     * Group by HotelRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelRoomGroupByArgs['orderBy'] }
        : { orderBy?: HotelRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelRoom model
   */
  readonly fields: HotelRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends HotelRoom$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, HotelRoom$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelRoom model
   */ 
  interface HotelRoomFieldRefs {
    readonly id: FieldRef<"HotelRoom", 'Int'>
    readonly hotelId: FieldRef<"HotelRoom", 'Int'>
    readonly roomType: FieldRef<"HotelRoom", 'String'>
    readonly roomName: FieldRef<"HotelRoom", 'String'>
    readonly description: FieldRef<"HotelRoom", 'String'>
    readonly imageUrl: FieldRef<"HotelRoom", 'String'>
    readonly images: FieldRef<"HotelRoom", 'String[]'>
    readonly maxOccupancy: FieldRef<"HotelRoom", 'Int'>
    readonly bedType: FieldRef<"HotelRoom", 'String'>
    readonly roomSize: FieldRef<"HotelRoom", 'String'>
    readonly amenities: FieldRef<"HotelRoom", 'String[]'>
    readonly pricePerNight: FieldRef<"HotelRoom", 'Int'>
    readonly totalRooms: FieldRef<"HotelRoom", 'Int'>
    readonly isActive: FieldRef<"HotelRoom", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HotelRoom findUnique
   */
  export type HotelRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom findUniqueOrThrow
   */
  export type HotelRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom findFirst
   */
  export type HotelRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRooms.
     */
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom findFirstOrThrow
   */
  export type HotelRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRooms.
     */
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom findMany
   */
  export type HotelRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRooms to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom create
   */
  export type HotelRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelRoom.
     */
    data: XOR<HotelRoomCreateInput, HotelRoomUncheckedCreateInput>
  }

  /**
   * HotelRoom createMany
   */
  export type HotelRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelRooms.
     */
    data: HotelRoomCreateManyInput | HotelRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelRoom createManyAndReturn
   */
  export type HotelRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelRooms.
     */
    data: HotelRoomCreateManyInput | HotelRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelRoom update
   */
  export type HotelRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelRoom.
     */
    data: XOR<HotelRoomUpdateInput, HotelRoomUncheckedUpdateInput>
    /**
     * Choose, which HotelRoom to update.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom updateMany
   */
  export type HotelRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelRooms.
     */
    data: XOR<HotelRoomUpdateManyMutationInput, HotelRoomUncheckedUpdateManyInput>
    /**
     * Filter which HotelRooms to update
     */
    where?: HotelRoomWhereInput
  }

  /**
   * HotelRoom upsert
   */
  export type HotelRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelRoom to update in case it exists.
     */
    where: HotelRoomWhereUniqueInput
    /**
     * In case the HotelRoom found by the `where` argument doesn't exist, create a new HotelRoom with this data.
     */
    create: XOR<HotelRoomCreateInput, HotelRoomUncheckedCreateInput>
    /**
     * In case the HotelRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelRoomUpdateInput, HotelRoomUncheckedUpdateInput>
  }

  /**
   * HotelRoom delete
   */
  export type HotelRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter which HotelRoom to delete.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom deleteMany
   */
  export type HotelRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRooms to delete
     */
    where?: HotelRoomWhereInput
  }

  /**
   * HotelRoom.bookings
   */
  export type HotelRoom$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelRoom without action
   */
  export type HotelRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
  }


  /**
   * Model HotelBooking
   */

  export type AggregateHotelBooking = {
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  export type HotelBookingAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
  }

  export type HotelBookingSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
  }

  export type HotelBookingMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type HotelBookingMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type HotelBookingCountAggregateOutputType = {
    id: number
    hotelId: number
    roomId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    checkInDate: number
    checkOutDate: number
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests: number
    status: number
    paymentStatus: number
    createdAt: number
    _all: number
  }


  export type HotelBookingAvgAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
  }

  export type HotelBookingSumAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
  }

  export type HotelBookingMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type HotelBookingMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type HotelBookingCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    _all?: true
  }

  export type HotelBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBooking to aggregate.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelBookings
    **/
    _count?: true | HotelBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelBookingMaxAggregateInputType
  }

  export type GetHotelBookingAggregateType<T extends HotelBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelBooking[P]>
      : GetScalarType<T[P], AggregateHotelBooking[P]>
  }




  export type HotelBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithAggregationInput | HotelBookingOrderByWithAggregationInput[]
    by: HotelBookingScalarFieldEnum[] | HotelBookingScalarFieldEnum
    having?: HotelBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelBookingCountAggregateInputType | true
    _avg?: HotelBookingAvgAggregateInputType
    _sum?: HotelBookingSumAggregateInputType
    _min?: HotelBookingMinAggregateInputType
    _max?: HotelBookingMaxAggregateInputType
  }

  export type HotelBookingGroupByOutputType = {
    id: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    checkInDate: Date
    checkOutDate: Date
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests: string | null
    status: string
    paymentStatus: string
    createdAt: Date
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  type GetHotelBookingGroupByPayload<T extends HotelBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
            : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
        }
      >
    >


  export type HotelBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
  }

  export type HotelBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }
  export type HotelBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }

  export type $HotelBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelBooking"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      room: Prisma.$HotelRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      roomId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      checkInDate: Date
      checkOutDate: Date
      numberOfRooms: number
      numberOfGuests: number
      totalAmount: number
      specialRequests: string | null
      status: string
      paymentStatus: string
      createdAt: Date
    }, ExtArgs["result"]["hotelBooking"]>
    composites: {}
  }

  type HotelBookingGetPayload<S extends boolean | null | undefined | HotelBookingDefaultArgs> = $Result.GetResult<Prisma.$HotelBookingPayload, S>

  type HotelBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelBookingCountAggregateInputType | true
    }

  export interface HotelBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelBooking'], meta: { name: 'HotelBooking' } }
    /**
     * Find zero or one HotelBooking that matches the filter.
     * @param {HotelBookingFindUniqueArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelBookingFindUniqueArgs>(args: SelectSubset<T, HotelBookingFindUniqueArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelBookingFindUniqueOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelBookingFindFirstArgs>(args?: SelectSubset<T, HotelBookingFindFirstArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany()
     * 
     * // Get first 10 HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelBookingFindManyArgs>(args?: SelectSubset<T, HotelBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelBooking.
     * @param {HotelBookingCreateArgs} args - Arguments to create a HotelBooking.
     * @example
     * // Create one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.create({
     *   data: {
     *     // ... data to create a HotelBooking
     *   }
     * })
     * 
     */
    create<T extends HotelBookingCreateArgs>(args: SelectSubset<T, HotelBookingCreateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelBookings.
     * @param {HotelBookingCreateManyArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelBookingCreateManyArgs>(args?: SelectSubset<T, HotelBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelBookings and returns the data saved in the database.
     * @param {HotelBookingCreateManyAndReturnArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelBookings and only return the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelBooking.
     * @param {HotelBookingDeleteArgs} args - Arguments to delete one HotelBooking.
     * @example
     * // Delete one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.delete({
     *   where: {
     *     // ... filter to delete one HotelBooking
     *   }
     * })
     * 
     */
    delete<T extends HotelBookingDeleteArgs>(args: SelectSubset<T, HotelBookingDeleteArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelBooking.
     * @param {HotelBookingUpdateArgs} args - Arguments to update one HotelBooking.
     * @example
     * // Update one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelBookingUpdateArgs>(args: SelectSubset<T, HotelBookingUpdateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelBookings.
     * @param {HotelBookingDeleteManyArgs} args - Arguments to filter HotelBookings to delete.
     * @example
     * // Delete a few HotelBookings
     * const { count } = await prisma.hotelBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelBookingDeleteManyArgs>(args?: SelectSubset<T, HotelBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelBookingUpdateManyArgs>(args: SelectSubset<T, HotelBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelBooking.
     * @param {HotelBookingUpsertArgs} args - Arguments to update or create a HotelBooking.
     * @example
     * // Update or create a HotelBooking
     * const hotelBooking = await prisma.hotelBooking.upsert({
     *   create: {
     *     // ... data to create a HotelBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelBooking we want to update
     *   }
     * })
     */
    upsert<T extends HotelBookingUpsertArgs>(args: SelectSubset<T, HotelBookingUpsertArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingCountArgs} args - Arguments to filter HotelBookings to count.
     * @example
     * // Count the number of HotelBookings
     * const count = await prisma.hotelBooking.count({
     *   where: {
     *     // ... the filter for the HotelBookings we want to count
     *   }
     * })
    **/
    count<T extends HotelBookingCountArgs>(
      args?: Subset<T, HotelBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelBookingAggregateArgs>(args: Subset<T, HotelBookingAggregateArgs>): Prisma.PrismaPromise<GetHotelBookingAggregateType<T>>

    /**
     * Group by HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelBookingGroupByArgs['orderBy'] }
        : { orderBy?: HotelBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelBooking model
   */
  readonly fields: HotelBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends HotelRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelRoomDefaultArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelBooking model
   */ 
  interface HotelBookingFieldRefs {
    readonly id: FieldRef<"HotelBooking", 'Int'>
    readonly hotelId: FieldRef<"HotelBooking", 'Int'>
    readonly roomId: FieldRef<"HotelBooking", 'Int'>
    readonly firstName: FieldRef<"HotelBooking", 'String'>
    readonly lastName: FieldRef<"HotelBooking", 'String'>
    readonly email: FieldRef<"HotelBooking", 'String'>
    readonly phone: FieldRef<"HotelBooking", 'String'>
    readonly checkInDate: FieldRef<"HotelBooking", 'DateTime'>
    readonly checkOutDate: FieldRef<"HotelBooking", 'DateTime'>
    readonly numberOfRooms: FieldRef<"HotelBooking", 'Int'>
    readonly numberOfGuests: FieldRef<"HotelBooking", 'Int'>
    readonly totalAmount: FieldRef<"HotelBooking", 'Int'>
    readonly specialRequests: FieldRef<"HotelBooking", 'String'>
    readonly status: FieldRef<"HotelBooking", 'String'>
    readonly paymentStatus: FieldRef<"HotelBooking", 'String'>
    readonly createdAt: FieldRef<"HotelBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelBooking findUnique
   */
  export type HotelBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findUniqueOrThrow
   */
  export type HotelBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findFirst
   */
  export type HotelBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findFirstOrThrow
   */
  export type HotelBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findMany
   */
  export type HotelBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBookings to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking create
   */
  export type HotelBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelBooking.
     */
    data: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
  }

  /**
   * HotelBooking createMany
   */
  export type HotelBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelBooking createManyAndReturn
   */
  export type HotelBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelBooking update
   */
  export type HotelBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelBooking.
     */
    data: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
    /**
     * Choose, which HotelBooking to update.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking updateMany
   */
  export type HotelBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelBookings.
     */
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyInput>
    /**
     * Filter which HotelBookings to update
     */
    where?: HotelBookingWhereInput
  }

  /**
   * HotelBooking upsert
   */
  export type HotelBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelBooking to update in case it exists.
     */
    where: HotelBookingWhereUniqueInput
    /**
     * In case the HotelBooking found by the `where` argument doesn't exist, create a new HotelBooking with this data.
     */
    create: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
    /**
     * In case the HotelBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
  }

  /**
   * HotelBooking delete
   */
  export type HotelBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter which HotelBooking to delete.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking deleteMany
   */
  export type HotelBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBookings to delete
     */
    where?: HotelBookingWhereInput
  }

  /**
   * HotelBooking without action
   */
  export type HotelBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
  }


  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountAvgAggregateOutputType = {
    id: number | null
  }

  export type UserAccountSumAggregateOutputType = {
    id: number | null
  }

  export type UserAccountMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    profileImage: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserAccountMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    profileImage: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserAccountCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    phone: number
    role: number
    isActive: number
    profileImage: number
    createdAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAccountAvgAggregateInputType = {
    id?: true
  }

  export type UserAccountSumAggregateInputType = {
    id?: true
  }

  export type UserAccountMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserAccountMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserAccountCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _avg?: UserAccountAvgAggregateInputType
    _sum?: UserAccountSumAggregateInputType
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone: string | null
    role: string
    isActive: boolean
    profileImage: string | null
    createdAt: Date
    lastLoginAt: Date | null
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    feedbacks?: boolean | UserAccount$feedbacksArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | UserAccount$feedbacksArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      feedbacks: Prisma.$UserFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      phone: string | null
      role: string
      isActive: boolean
      profileImage: string | null
      createdAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }

  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccountFindUniqueArgs>(args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccountFindFirstArgs>(args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAccountFindManyArgs>(args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
     */
    create<T extends UserAccountCreateArgs>(args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAccounts.
     * @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccountCreateManyArgs>(args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAccounts and returns the data saved in the database.
     * @param {UserAccountCreateManyAndReturnArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAccounts and only return the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
     */
    delete<T extends UserAccountDeleteArgs>(args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccountUpdateArgs>(args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccountDeleteManyArgs>(args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccountUpdateManyArgs>(args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserAccountUpsertArgs>(args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedbacks<T extends UserAccount$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccount model
   */ 
  interface UserAccountFieldRefs {
    readonly id: FieldRef<"UserAccount", 'Int'>
    readonly email: FieldRef<"UserAccount", 'String'>
    readonly password: FieldRef<"UserAccount", 'String'>
    readonly firstName: FieldRef<"UserAccount", 'String'>
    readonly lastName: FieldRef<"UserAccount", 'String'>
    readonly phone: FieldRef<"UserAccount", 'String'>
    readonly role: FieldRef<"UserAccount", 'String'>
    readonly isActive: FieldRef<"UserAccount", 'Boolean'>
    readonly profileImage: FieldRef<"UserAccount", 'String'>
    readonly createdAt: FieldRef<"UserAccount", 'DateTime'>
    readonly lastLoginAt: FieldRef<"UserAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }

  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount createManyAndReturn
   */
  export type UserAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
  }

  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }

  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
  }

  /**
   * UserAccount.feedbacks
   */
  export type UserAccount$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserFeedback
   */

  export type AggregateUserFeedback = {
    _count: UserFeedbackCountAggregateOutputType | null
    _avg: UserFeedbackAvgAggregateOutputType | null
    _sum: UserFeedbackSumAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  export type UserFeedbackAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
  }

  export type UserFeedbackSumAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
  }

  export type UserFeedbackMinAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
    comment: string | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type UserFeedbackMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
    comment: string | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type UserFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    itineraryId: number
    tourId: number
    rating: number
    comment: number
    category: number
    isPublic: number
    createdAt: number
    _all: number
  }


  export type UserFeedbackAvgAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
  }

  export type UserFeedbackSumAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
  }

  export type UserFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
  }

  export type UserFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
  }

  export type UserFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
    _all?: true
  }

  export type UserFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedback to aggregate.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeedbacks
    **/
    _count?: true | UserFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type GetUserFeedbackAggregateType<T extends UserFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeedback[P]>
      : GetScalarType<T[P], AggregateUserFeedback[P]>
  }




  export type UserFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithAggregationInput | UserFeedbackOrderByWithAggregationInput[]
    by: UserFeedbackScalarFieldEnum[] | UserFeedbackScalarFieldEnum
    having?: UserFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeedbackCountAggregateInputType | true
    _avg?: UserFeedbackAvgAggregateInputType
    _sum?: UserFeedbackSumAggregateInputType
    _min?: UserFeedbackMinAggregateInputType
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type UserFeedbackGroupByOutputType = {
    id: number
    userId: number
    itineraryId: number | null
    tourId: number | null
    rating: number
    comment: string | null
    category: string
    isPublic: boolean
    createdAt: Date
    _count: UserFeedbackCountAggregateOutputType | null
    _avg: UserFeedbackAvgAggregateOutputType | null
    _sum: UserFeedbackSumAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  type GetUserFeedbackGroupByPayload<T extends UserFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type UserFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
  }

  export type UserFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }
  export type UserFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }

  export type $UserFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeedback"
    objects: {
      user: Prisma.$UserAccountPayload<ExtArgs>
      itinerary: Prisma.$ItineraryPayload<ExtArgs> | null
      tour: Prisma.$TourPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      itineraryId: number | null
      tourId: number | null
      rating: number
      comment: string | null
      category: string
      isPublic: boolean
      createdAt: Date
    }, ExtArgs["result"]["userFeedback"]>
    composites: {}
  }

  type UserFeedbackGetPayload<S extends boolean | null | undefined | UserFeedbackDefaultArgs> = $Result.GetResult<Prisma.$UserFeedbackPayload, S>

  type UserFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFeedbackCountAggregateInputType | true
    }

  export interface UserFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeedback'], meta: { name: 'UserFeedback' } }
    /**
     * Find zero or one UserFeedback that matches the filter.
     * @param {UserFeedbackFindUniqueArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeedbackFindUniqueArgs>(args: SelectSubset<T, UserFeedbackFindUniqueArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFeedbackFindUniqueOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeedbackFindFirstArgs>(args?: SelectSubset<T, UserFeedbackFindFirstArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany()
     * 
     * // Get first 10 UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeedbackFindManyArgs>(args?: SelectSubset<T, UserFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFeedback.
     * @param {UserFeedbackCreateArgs} args - Arguments to create a UserFeedback.
     * @example
     * // Create one UserFeedback
     * const UserFeedback = await prisma.userFeedback.create({
     *   data: {
     *     // ... data to create a UserFeedback
     *   }
     * })
     * 
     */
    create<T extends UserFeedbackCreateArgs>(args: SelectSubset<T, UserFeedbackCreateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFeedbacks.
     * @param {UserFeedbackCreateManyArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeedbackCreateManyArgs>(args?: SelectSubset<T, UserFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeedbacks and returns the data saved in the database.
     * @param {UserFeedbackCreateManyAndReturnArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeedbacks and only return the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFeedback.
     * @param {UserFeedbackDeleteArgs} args - Arguments to delete one UserFeedback.
     * @example
     * // Delete one UserFeedback
     * const UserFeedback = await prisma.userFeedback.delete({
     *   where: {
     *     // ... filter to delete one UserFeedback
     *   }
     * })
     * 
     */
    delete<T extends UserFeedbackDeleteArgs>(args: SelectSubset<T, UserFeedbackDeleteArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFeedback.
     * @param {UserFeedbackUpdateArgs} args - Arguments to update one UserFeedback.
     * @example
     * // Update one UserFeedback
     * const userFeedback = await prisma.userFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeedbackUpdateArgs>(args: SelectSubset<T, UserFeedbackUpdateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFeedbacks.
     * @param {UserFeedbackDeleteManyArgs} args - Arguments to filter UserFeedbacks to delete.
     * @example
     * // Delete a few UserFeedbacks
     * const { count } = await prisma.userFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeedbackDeleteManyArgs>(args?: SelectSubset<T, UserFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeedbackUpdateManyArgs>(args: SelectSubset<T, UserFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFeedback.
     * @param {UserFeedbackUpsertArgs} args - Arguments to update or create a UserFeedback.
     * @example
     * // Update or create a UserFeedback
     * const userFeedback = await prisma.userFeedback.upsert({
     *   create: {
     *     // ... data to create a UserFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeedback we want to update
     *   }
     * })
     */
    upsert<T extends UserFeedbackUpsertArgs>(args: SelectSubset<T, UserFeedbackUpsertArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackCountArgs} args - Arguments to filter UserFeedbacks to count.
     * @example
     * // Count the number of UserFeedbacks
     * const count = await prisma.userFeedback.count({
     *   where: {
     *     // ... the filter for the UserFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends UserFeedbackCountArgs>(
      args?: Subset<T, UserFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeedbackAggregateArgs>(args: Subset<T, UserFeedbackAggregateArgs>): Prisma.PrismaPromise<GetUserFeedbackAggregateType<T>>

    /**
     * Group by UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: UserFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeedback model
   */
  readonly fields: UserFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAccountDefaultArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    itinerary<T extends UserFeedback$itineraryArgs<ExtArgs> = {}>(args?: Subset<T, UserFeedback$itineraryArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tour<T extends UserFeedback$tourArgs<ExtArgs> = {}>(args?: Subset<T, UserFeedback$tourArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeedback model
   */ 
  interface UserFeedbackFieldRefs {
    readonly id: FieldRef<"UserFeedback", 'Int'>
    readonly userId: FieldRef<"UserFeedback", 'Int'>
    readonly itineraryId: FieldRef<"UserFeedback", 'Int'>
    readonly tourId: FieldRef<"UserFeedback", 'Int'>
    readonly rating: FieldRef<"UserFeedback", 'Int'>
    readonly comment: FieldRef<"UserFeedback", 'String'>
    readonly category: FieldRef<"UserFeedback", 'String'>
    readonly isPublic: FieldRef<"UserFeedback", 'Boolean'>
    readonly createdAt: FieldRef<"UserFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeedback findUnique
   */
  export type UserFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findUniqueOrThrow
   */
  export type UserFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findFirst
   */
  export type UserFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findFirstOrThrow
   */
  export type UserFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findMany
   */
  export type UserFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedbacks to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback create
   */
  export type UserFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeedback.
     */
    data: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
  }

  /**
   * UserFeedback createMany
   */
  export type UserFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeedback createManyAndReturn
   */
  export type UserFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeedback update
   */
  export type UserFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeedback.
     */
    data: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
    /**
     * Choose, which UserFeedback to update.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback updateMany
   */
  export type UserFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeedbacks.
     */
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which UserFeedbacks to update
     */
    where?: UserFeedbackWhereInput
  }

  /**
   * UserFeedback upsert
   */
  export type UserFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeedback to update in case it exists.
     */
    where: UserFeedbackWhereUniqueInput
    /**
     * In case the UserFeedback found by the `where` argument doesn't exist, create a new UserFeedback with this data.
     */
    create: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
    /**
     * In case the UserFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
  }

  /**
   * UserFeedback delete
   */
  export type UserFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter which UserFeedback to delete.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback deleteMany
   */
  export type UserFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedbacks to delete
     */
    where?: UserFeedbackWhereInput
  }

  /**
   * UserFeedback.itinerary
   */
  export type UserFeedback$itineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
  }

  /**
   * UserFeedback.tour
   */
  export type UserFeedback$tourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
  }

  /**
   * UserFeedback without action
   */
  export type UserFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    duration: 'duration',
    price: 'price',
    category: 'category',
    imageUrl: 'imageUrl',
    rating: 'rating',
    reviewCount: 'reviewCount',
    highlights: 'highlights',
    isActive: 'isActive',
    maxGroupSize: 'maxGroupSize',
    difficulty: 'difficulty',
    bestSeason: 'bestSeason',
    includes: 'includes',
    excludes: 'excludes',
    tourOperatorId: 'tourOperatorId'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    travelDate: 'travelDate',
    groupSize: 'groupSize',
    specialRequests: 'specialRequests',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    tourInterest: 'tourInterest',
    preferredDates: 'preferredDates',
    groupSize: 'groupSize',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country: 'country',
    imageUrl: 'imageUrl',
    text: 'text',
    rating: 'rating',
    tripName: 'tripName',
    duration: 'duration',
    isActive: 'isActive'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    imageUrl: 'imageUrl',
    category: 'category',
    author: 'author',
    authorImage: 'authorImage',
    readTime: 'readTime',
    publishedAt: 'publishedAt',
    isPublished: 'isPublished'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const GuideScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    licenseImageUrl: 'licenseImageUrl',
    registrationType: 'registrationType',
    specializations: 'specializations',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type GuideScalarFieldEnum = (typeof GuideScalarFieldEnum)[keyof typeof GuideScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    guideId: 'guideId',
    driverId: 'driverId',
    maxParticipants: 'maxParticipants',
    currentParticipants: 'currentParticipants',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const ItineraryDayScalarFieldEnum: {
    id: 'id',
    itineraryId: 'itineraryId',
    dayNumber: 'dayNumber',
    title: 'title',
    description: 'description',
    activities: 'activities',
    accommodation: 'accommodation',
    meals: 'meals',
    transportation: 'transportation',
    notes: 'notes'
  };

  export type ItineraryDayScalarFieldEnum = (typeof ItineraryDayScalarFieldEnum)[keyof typeof ItineraryDayScalarFieldEnum]


  export const CustomTourRequestScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    duration: 'duration',
    groupSize: 'groupSize',
    budget: 'budget',
    interests: 'interests',
    preferredDates: 'preferredDates',
    specialRequirements: 'specialRequirements',
    destinations: 'destinations',
    accommodationType: 'accommodationType',
    transportPreference: 'transportPreference',
    status: 'status',
    adminNotes: 'adminNotes',
    estimatedPrice: 'estimatedPrice',
    assignedItineraryId: 'assignedItineraryId',
    createdAt: 'createdAt'
  };

  export type CustomTourRequestScalarFieldEnum = (typeof CustomTourRequestScalarFieldEnum)[keyof typeof CustomTourRequestScalarFieldEnum]


  export const TourOperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    website: 'website',
    description: 'description',
    bestFeature: 'bestFeature',
    specialties: 'specialties',
    rating: 'rating',
    reviewCount: 'reviewCount',
    logoUrl: 'logoUrl',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    isActive: 'isActive',
    establishedYear: 'establishedYear',
    certifications: 'certifications',
    awards: 'awards',
    createdAt: 'createdAt'
  };

  export type TourOperatorScalarFieldEnum = (typeof TourOperatorScalarFieldEnum)[keyof typeof TourOperatorScalarFieldEnum]


  export const FestivalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    startDate: 'startDate',
    endDate: 'endDate',
    imageUrl: 'imageUrl',
    category: 'category',
    highlights: 'highlights',
    isActive: 'isActive',
    ticketPrice: 'ticketPrice',
    maxCapacity: 'maxCapacity',
    createdAt: 'createdAt'
  };

  export type FestivalScalarFieldEnum = (typeof FestivalScalarFieldEnum)[keyof typeof FestivalScalarFieldEnum]


  export const FestivalBookingScalarFieldEnum: {
    id: 'id',
    festivalId: 'festivalId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    numberOfTickets: 'numberOfTickets',
    totalAmount: 'totalAmount',
    specialRequests: 'specialRequests',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FestivalBookingScalarFieldEnum = (typeof FestivalBookingScalarFieldEnum)[keyof typeof FestivalBookingScalarFieldEnum]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    address: 'address',
    imageUrl: 'imageUrl',
    images: 'images',
    category: 'category',
    starRating: 'starRating',
    amenities: 'amenities',
    features: 'features',
    pricePerNight: 'pricePerNight',
    isActive: 'isActive',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    cancellationPolicy: 'cancellationPolicy',
    createdAt: 'createdAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const HotelRoomScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomType: 'roomType',
    roomName: 'roomName',
    description: 'description',
    imageUrl: 'imageUrl',
    images: 'images',
    maxOccupancy: 'maxOccupancy',
    bedType: 'bedType',
    roomSize: 'roomSize',
    amenities: 'amenities',
    pricePerNight: 'pricePerNight',
    totalRooms: 'totalRooms',
    isActive: 'isActive'
  };

  export type HotelRoomScalarFieldEnum = (typeof HotelRoomScalarFieldEnum)[keyof typeof HotelRoomScalarFieldEnum]


  export const HotelBookingScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomId: 'roomId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    numberOfRooms: 'numberOfRooms',
    numberOfGuests: 'numberOfGuests',
    totalAmount: 'totalAmount',
    specialRequests: 'specialRequests',
    status: 'status',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt'
  };

  export type HotelBookingScalarFieldEnum = (typeof HotelBookingScalarFieldEnum)[keyof typeof HotelBookingScalarFieldEnum]


  export const UserAccountScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const UserFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itineraryId: 'itineraryId',
    tourId: 'tourId',
    rating: 'rating',
    comment: 'comment',
    category: 'category',
    isPublic: 'isPublic',
    createdAt: 'createdAt'
  };

  export type UserFeedbackScalarFieldEnum = (typeof UserFeedbackScalarFieldEnum)[keyof typeof UserFeedbackScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type TourWhereInput = {
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    id?: IntFilter<"Tour"> | number
    name?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    duration?: IntFilter<"Tour"> | number
    price?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    imageUrl?: StringFilter<"Tour"> | string
    rating?: FloatFilter<"Tour"> | number
    reviewCount?: IntFilter<"Tour"> | number
    highlights?: StringNullableListFilter<"Tour">
    isActive?: BoolFilter<"Tour"> | boolean
    maxGroupSize?: IntFilter<"Tour"> | number
    difficulty?: StringFilter<"Tour"> | string
    bestSeason?: StringFilter<"Tour"> | string
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
    bookings?: BookingListRelationFilter
    itineraries?: ItineraryListRelationFilter
    TourOperator?: XOR<TourOperatorNullableRelationFilter, TourOperatorWhereInput> | null
    UserFeedback?: UserFeedbackListRelationFilter
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    maxGroupSize?: SortOrder
    difficulty?: SortOrder
    bestSeason?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    tourOperatorId?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    itineraries?: ItineraryOrderByRelationAggregateInput
    TourOperator?: TourOperatorOrderByWithRelationInput
    UserFeedback?: UserFeedbackOrderByRelationAggregateInput
  }

  export type TourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    name?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    duration?: IntFilter<"Tour"> | number
    price?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    imageUrl?: StringFilter<"Tour"> | string
    rating?: FloatFilter<"Tour"> | number
    reviewCount?: IntFilter<"Tour"> | number
    highlights?: StringNullableListFilter<"Tour">
    isActive?: BoolFilter<"Tour"> | boolean
    maxGroupSize?: IntFilter<"Tour"> | number
    difficulty?: StringFilter<"Tour"> | string
    bestSeason?: StringFilter<"Tour"> | string
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
    bookings?: BookingListRelationFilter
    itineraries?: ItineraryListRelationFilter
    TourOperator?: XOR<TourOperatorNullableRelationFilter, TourOperatorWhereInput> | null
    UserFeedback?: UserFeedbackListRelationFilter
  }, "id">

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    maxGroupSize?: SortOrder
    difficulty?: SortOrder
    bestSeason?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    tourOperatorId?: SortOrderInput | SortOrder
    _count?: TourCountOrderByAggregateInput
    _avg?: TourAvgOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
    _sum?: TourSumOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    OR?: TourScalarWhereWithAggregatesInput[]
    NOT?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tour"> | number
    name?: StringWithAggregatesFilter<"Tour"> | string
    description?: StringWithAggregatesFilter<"Tour"> | string
    duration?: IntWithAggregatesFilter<"Tour"> | number
    price?: IntWithAggregatesFilter<"Tour"> | number
    category?: StringWithAggregatesFilter<"Tour"> | string
    imageUrl?: StringWithAggregatesFilter<"Tour"> | string
    rating?: FloatWithAggregatesFilter<"Tour"> | number
    reviewCount?: IntWithAggregatesFilter<"Tour"> | number
    highlights?: StringNullableListFilter<"Tour">
    isActive?: BoolWithAggregatesFilter<"Tour"> | boolean
    maxGroupSize?: IntWithAggregatesFilter<"Tour"> | number
    difficulty?: StringWithAggregatesFilter<"Tour"> | string
    bestSeason?: StringWithAggregatesFilter<"Tour"> | string
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    tourOperatorId?: IntNullableWithAggregatesFilter<"Tour"> | number | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    tour?: TourOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    tourId?: IntWithAggregatesFilter<"Booking"> | number
    firstName?: StringWithAggregatesFilter<"Booking"> | string
    lastName?: StringWithAggregatesFilter<"Booking"> | string
    email?: StringWithAggregatesFilter<"Booking"> | string
    phone?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    travelDate?: StringWithAggregatesFilter<"Booking"> | string
    groupSize?: IntWithAggregatesFilter<"Booking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: IntFilter<"Inquiry"> | number
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableFilter<"Inquiry"> | string | null
    groupSize?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringNullableFilter<"Inquiry"> | string | null
    status?: StringFilter<"Inquiry"> | string
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    tourInterest?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableFilter<"Inquiry"> | string | null
    groupSize?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringNullableFilter<"Inquiry"> | string | null
    status?: StringFilter<"Inquiry"> | string
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    tourInterest?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inquiry"> | number
    firstName?: StringWithAggregatesFilter<"Inquiry"> | string
    lastName?: StringWithAggregatesFilter<"Inquiry"> | string
    email?: StringWithAggregatesFilter<"Inquiry"> | string
    phone?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    groupSize?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    message?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    status?: StringWithAggregatesFilter<"Inquiry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: IntFilter<"Testimonial"> | number
    name?: StringFilter<"Testimonial"> | string
    country?: StringFilter<"Testimonial"> | string
    imageUrl?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    tripName?: StringFilter<"Testimonial"> | string
    duration?: StringFilter<"Testimonial"> | string
    isActive?: BoolFilter<"Testimonial"> | boolean
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    name?: StringFilter<"Testimonial"> | string
    country?: StringFilter<"Testimonial"> | string
    imageUrl?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    tripName?: StringFilter<"Testimonial"> | string
    duration?: StringFilter<"Testimonial"> | string
    isActive?: BoolFilter<"Testimonial"> | boolean
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Testimonial"> | number
    name?: StringWithAggregatesFilter<"Testimonial"> | string
    country?: StringWithAggregatesFilter<"Testimonial"> | string
    imageUrl?: StringWithAggregatesFilter<"Testimonial"> | string
    text?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    tripName?: StringWithAggregatesFilter<"Testimonial"> | string
    duration?: StringWithAggregatesFilter<"Testimonial"> | string
    isActive?: BoolWithAggregatesFilter<"Testimonial"> | boolean
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    imageUrl?: StringFilter<"BlogPost"> | string
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    authorImage?: StringFilter<"BlogPost"> | string
    readTime?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeFilter<"BlogPost"> | Date | string
    isPublished?: BoolFilter<"BlogPost"> | boolean
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    imageUrl?: StringFilter<"BlogPost"> | string
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    authorImage?: StringFilter<"BlogPost"> | string
    readTime?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeFilter<"BlogPost"> | Date | string
    isPublished?: BoolFilter<"BlogPost"> | boolean
  }, "id">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogPost"> | number
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    imageUrl?: StringWithAggregatesFilter<"BlogPost"> | string
    category?: StringWithAggregatesFilter<"BlogPost"> | string
    author?: StringWithAggregatesFilter<"BlogPost"> | string
    authorImage?: StringWithAggregatesFilter<"BlogPost"> | string
    readTime?: StringWithAggregatesFilter<"BlogPost"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"BlogPost"> | boolean
  }

  export type GuideWhereInput = {
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    id?: IntFilter<"Guide"> | number
    name?: StringFilter<"Guide"> | string
    email?: StringFilter<"Guide"> | string
    phone?: StringFilter<"Guide"> | string
    licenseImageUrl?: StringFilter<"Guide"> | string
    registrationType?: StringFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    guidedItineraries?: ItineraryListRelationFilter
    drivenItineraries?: ItineraryListRelationFilter
  }

  export type GuideOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    guidedItineraries?: ItineraryOrderByRelationAggregateInput
    drivenItineraries?: ItineraryOrderByRelationAggregateInput
  }

  export type GuideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    name?: StringFilter<"Guide"> | string
    phone?: StringFilter<"Guide"> | string
    licenseImageUrl?: StringFilter<"Guide"> | string
    registrationType?: StringFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    guidedItineraries?: ItineraryListRelationFilter
    drivenItineraries?: ItineraryListRelationFilter
  }, "id" | "email">

  export type GuideOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: GuideCountOrderByAggregateInput
    _avg?: GuideAvgOrderByAggregateInput
    _max?: GuideMaxOrderByAggregateInput
    _min?: GuideMinOrderByAggregateInput
    _sum?: GuideSumOrderByAggregateInput
  }

  export type GuideScalarWhereWithAggregatesInput = {
    AND?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    OR?: GuideScalarWhereWithAggregatesInput[]
    NOT?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Guide"> | number
    name?: StringWithAggregatesFilter<"Guide"> | string
    email?: StringWithAggregatesFilter<"Guide"> | string
    phone?: StringWithAggregatesFilter<"Guide"> | string
    licenseImageUrl?: StringWithAggregatesFilter<"Guide"> | string
    registrationType?: StringWithAggregatesFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringWithAggregatesFilter<"Guide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
  }

  export type ItineraryWhereInput = {
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    guide?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    driver?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    days?: ItineraryDayListRelationFilter
    assignedCustomTourRequests?: CustomTourRequestListRelationFilter
    UserFeedback?: UserFeedbackListRelationFilter
  }

  export type ItineraryOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    tour?: TourOrderByWithRelationInput
    guide?: GuideOrderByWithRelationInput
    driver?: GuideOrderByWithRelationInput
    days?: ItineraryDayOrderByRelationAggregateInput
    assignedCustomTourRequests?: CustomTourRequestOrderByRelationAggregateInput
    UserFeedback?: UserFeedbackOrderByRelationAggregateInput
  }

  export type ItineraryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    guide?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    driver?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    days?: ItineraryDayListRelationFilter
    assignedCustomTourRequests?: CustomTourRequestListRelationFilter
    UserFeedback?: UserFeedbackListRelationFilter
  }, "id">

  export type ItineraryOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _avg?: ItineraryAvgOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
    _sum?: ItinerarySumOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    OR?: ItineraryScalarWhereWithAggregatesInput[]
    NOT?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Itinerary"> | number
    tourId?: IntWithAggregatesFilter<"Itinerary"> | number
    name?: StringWithAggregatesFilter<"Itinerary"> | string
    description?: StringNullableWithAggregatesFilter<"Itinerary"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
    guideId?: IntNullableWithAggregatesFilter<"Itinerary"> | number | null
    driverId?: IntNullableWithAggregatesFilter<"Itinerary"> | number | null
    maxParticipants?: IntWithAggregatesFilter<"Itinerary"> | number
    currentParticipants?: IntWithAggregatesFilter<"Itinerary"> | number
    status?: StringWithAggregatesFilter<"Itinerary"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
  }

  export type ItineraryDayWhereInput = {
    AND?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    OR?: ItineraryDayWhereInput[]
    NOT?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    id?: IntFilter<"ItineraryDay"> | number
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
  }

  export type ItineraryDayOrderByWithRelationInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrderInput | SortOrder
    meals?: SortOrder
    transportation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    itinerary?: ItineraryOrderByWithRelationInput
  }

  export type ItineraryDayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    OR?: ItineraryDayWhereInput[]
    NOT?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
  }, "id">

  export type ItineraryDayOrderByWithAggregationInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrderInput | SortOrder
    meals?: SortOrder
    transportation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ItineraryDayCountOrderByAggregateInput
    _avg?: ItineraryDayAvgOrderByAggregateInput
    _max?: ItineraryDayMaxOrderByAggregateInput
    _min?: ItineraryDayMinOrderByAggregateInput
    _sum?: ItineraryDaySumOrderByAggregateInput
  }

  export type ItineraryDayScalarWhereWithAggregatesInput = {
    AND?: ItineraryDayScalarWhereWithAggregatesInput | ItineraryDayScalarWhereWithAggregatesInput[]
    OR?: ItineraryDayScalarWhereWithAggregatesInput[]
    NOT?: ItineraryDayScalarWhereWithAggregatesInput | ItineraryDayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItineraryDay"> | number
    itineraryId?: IntWithAggregatesFilter<"ItineraryDay"> | number
    dayNumber?: IntWithAggregatesFilter<"ItineraryDay"> | number
    title?: StringWithAggregatesFilter<"ItineraryDay"> | string
    description?: StringWithAggregatesFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
  }

  export type CustomTourRequestWhereInput = {
    AND?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    OR?: CustomTourRequestWhereInput[]
    NOT?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    id?: IntFilter<"CustomTourRequest"> | number
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    interests?: StringNullableListFilter<"CustomTourRequest">
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
    assignedItinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
  }

  export type CustomTourRequestOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrderInput | SortOrder
    interests?: SortOrder
    preferredDates?: SortOrderInput | SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrderInput | SortOrder
    transportPreference?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    assignedItineraryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    assignedItinerary?: ItineraryOrderByWithRelationInput
  }

  export type CustomTourRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    OR?: CustomTourRequestWhereInput[]
    NOT?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    interests?: StringNullableListFilter<"CustomTourRequest">
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
    assignedItinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
  }, "id">

  export type CustomTourRequestOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrderInput | SortOrder
    interests?: SortOrder
    preferredDates?: SortOrderInput | SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrderInput | SortOrder
    transportPreference?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    assignedItineraryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomTourRequestCountOrderByAggregateInput
    _avg?: CustomTourRequestAvgOrderByAggregateInput
    _max?: CustomTourRequestMaxOrderByAggregateInput
    _min?: CustomTourRequestMinOrderByAggregateInput
    _sum?: CustomTourRequestSumOrderByAggregateInput
  }

  export type CustomTourRequestScalarWhereWithAggregatesInput = {
    AND?: CustomTourRequestScalarWhereWithAggregatesInput | CustomTourRequestScalarWhereWithAggregatesInput[]
    OR?: CustomTourRequestScalarWhereWithAggregatesInput[]
    NOT?: CustomTourRequestScalarWhereWithAggregatesInput | CustomTourRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    firstName?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    lastName?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    email?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    phone?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    duration?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    groupSize?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    budget?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    interests?: StringNullableListFilter<"CustomTourRequest">
    preferredDates?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    status?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomTourRequest"> | Date | string
  }

  export type TourOperatorWhereInput = {
    AND?: TourOperatorWhereInput | TourOperatorWhereInput[]
    OR?: TourOperatorWhereInput[]
    NOT?: TourOperatorWhereInput | TourOperatorWhereInput[]
    id?: IntFilter<"TourOperator"> | number
    name?: StringFilter<"TourOperator"> | string
    website?: StringFilter<"TourOperator"> | string
    description?: StringFilter<"TourOperator"> | string
    bestFeature?: StringFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatFilter<"TourOperator"> | number
    reviewCount?: IntFilter<"TourOperator"> | number
    logoUrl?: StringNullableFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableFilter<"TourOperator"> | string | null
    isActive?: BoolFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeFilter<"TourOperator"> | Date | string
    tours?: TourListRelationFilter
  }

  export type TourOperatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrderInput | SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
    tours?: TourOrderByRelationAggregateInput
  }

  export type TourOperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TourOperatorWhereInput | TourOperatorWhereInput[]
    OR?: TourOperatorWhereInput[]
    NOT?: TourOperatorWhereInput | TourOperatorWhereInput[]
    website?: StringFilter<"TourOperator"> | string
    description?: StringFilter<"TourOperator"> | string
    bestFeature?: StringFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatFilter<"TourOperator"> | number
    reviewCount?: IntFilter<"TourOperator"> | number
    logoUrl?: StringNullableFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableFilter<"TourOperator"> | string | null
    isActive?: BoolFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeFilter<"TourOperator"> | Date | string
    tours?: TourListRelationFilter
  }, "id" | "name">

  export type TourOperatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrderInput | SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
    _count?: TourOperatorCountOrderByAggregateInput
    _avg?: TourOperatorAvgOrderByAggregateInput
    _max?: TourOperatorMaxOrderByAggregateInput
    _min?: TourOperatorMinOrderByAggregateInput
    _sum?: TourOperatorSumOrderByAggregateInput
  }

  export type TourOperatorScalarWhereWithAggregatesInput = {
    AND?: TourOperatorScalarWhereWithAggregatesInput | TourOperatorScalarWhereWithAggregatesInput[]
    OR?: TourOperatorScalarWhereWithAggregatesInput[]
    NOT?: TourOperatorScalarWhereWithAggregatesInput | TourOperatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TourOperator"> | number
    name?: StringWithAggregatesFilter<"TourOperator"> | string
    website?: StringWithAggregatesFilter<"TourOperator"> | string
    description?: StringWithAggregatesFilter<"TourOperator"> | string
    bestFeature?: StringWithAggregatesFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatWithAggregatesFilter<"TourOperator"> | number
    reviewCount?: IntWithAggregatesFilter<"TourOperator"> | number
    logoUrl?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    isActive?: BoolWithAggregatesFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableWithAggregatesFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeWithAggregatesFilter<"TourOperator"> | Date | string
  }

  export type FestivalWhereInput = {
    AND?: FestivalWhereInput | FestivalWhereInput[]
    OR?: FestivalWhereInput[]
    NOT?: FestivalWhereInput | FestivalWhereInput[]
    id?: IntFilter<"Festival"> | number
    name?: StringFilter<"Festival"> | string
    description?: StringFilter<"Festival"> | string
    location?: StringFilter<"Festival"> | string
    startDate?: DateTimeFilter<"Festival"> | Date | string
    endDate?: DateTimeFilter<"Festival"> | Date | string
    imageUrl?: StringFilter<"Festival"> | string
    category?: StringFilter<"Festival"> | string
    highlights?: StringNullableListFilter<"Festival">
    isActive?: BoolFilter<"Festival"> | boolean
    ticketPrice?: IntNullableFilter<"Festival"> | number | null
    maxCapacity?: IntNullableFilter<"Festival"> | number | null
    createdAt?: DateTimeFilter<"Festival"> | Date | string
    bookings?: FestivalBookingListRelationFilter
  }

  export type FestivalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    ticketPrice?: SortOrderInput | SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bookings?: FestivalBookingOrderByRelationAggregateInput
  }

  export type FestivalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FestivalWhereInput | FestivalWhereInput[]
    OR?: FestivalWhereInput[]
    NOT?: FestivalWhereInput | FestivalWhereInput[]
    name?: StringFilter<"Festival"> | string
    description?: StringFilter<"Festival"> | string
    location?: StringFilter<"Festival"> | string
    startDate?: DateTimeFilter<"Festival"> | Date | string
    endDate?: DateTimeFilter<"Festival"> | Date | string
    imageUrl?: StringFilter<"Festival"> | string
    category?: StringFilter<"Festival"> | string
    highlights?: StringNullableListFilter<"Festival">
    isActive?: BoolFilter<"Festival"> | boolean
    ticketPrice?: IntNullableFilter<"Festival"> | number | null
    maxCapacity?: IntNullableFilter<"Festival"> | number | null
    createdAt?: DateTimeFilter<"Festival"> | Date | string
    bookings?: FestivalBookingListRelationFilter
  }, "id">

  export type FestivalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    ticketPrice?: SortOrderInput | SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FestivalCountOrderByAggregateInput
    _avg?: FestivalAvgOrderByAggregateInput
    _max?: FestivalMaxOrderByAggregateInput
    _min?: FestivalMinOrderByAggregateInput
    _sum?: FestivalSumOrderByAggregateInput
  }

  export type FestivalScalarWhereWithAggregatesInput = {
    AND?: FestivalScalarWhereWithAggregatesInput | FestivalScalarWhereWithAggregatesInput[]
    OR?: FestivalScalarWhereWithAggregatesInput[]
    NOT?: FestivalScalarWhereWithAggregatesInput | FestivalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Festival"> | number
    name?: StringWithAggregatesFilter<"Festival"> | string
    description?: StringWithAggregatesFilter<"Festival"> | string
    location?: StringWithAggregatesFilter<"Festival"> | string
    startDate?: DateTimeWithAggregatesFilter<"Festival"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Festival"> | Date | string
    imageUrl?: StringWithAggregatesFilter<"Festival"> | string
    category?: StringWithAggregatesFilter<"Festival"> | string
    highlights?: StringNullableListFilter<"Festival">
    isActive?: BoolWithAggregatesFilter<"Festival"> | boolean
    ticketPrice?: IntNullableWithAggregatesFilter<"Festival"> | number | null
    maxCapacity?: IntNullableWithAggregatesFilter<"Festival"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Festival"> | Date | string
  }

  export type FestivalBookingWhereInput = {
    AND?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    OR?: FestivalBookingWhereInput[]
    NOT?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    id?: IntFilter<"FestivalBooking"> | number
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }

  export type FestivalBookingOrderByWithRelationInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    festival?: FestivalOrderByWithRelationInput
  }

  export type FestivalBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    OR?: FestivalBookingWhereInput[]
    NOT?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }, "id">

  export type FestivalBookingOrderByWithAggregationInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FestivalBookingCountOrderByAggregateInput
    _avg?: FestivalBookingAvgOrderByAggregateInput
    _max?: FestivalBookingMaxOrderByAggregateInput
    _min?: FestivalBookingMinOrderByAggregateInput
    _sum?: FestivalBookingSumOrderByAggregateInput
  }

  export type FestivalBookingScalarWhereWithAggregatesInput = {
    AND?: FestivalBookingScalarWhereWithAggregatesInput | FestivalBookingScalarWhereWithAggregatesInput[]
    OR?: FestivalBookingScalarWhereWithAggregatesInput[]
    NOT?: FestivalBookingScalarWhereWithAggregatesInput | FestivalBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FestivalBooking"> | number
    festivalId?: IntWithAggregatesFilter<"FestivalBooking"> | number
    firstName?: StringWithAggregatesFilter<"FestivalBooking"> | string
    lastName?: StringWithAggregatesFilter<"FestivalBooking"> | string
    email?: StringWithAggregatesFilter<"FestivalBooking"> | string
    phone?: StringNullableWithAggregatesFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntWithAggregatesFilter<"FestivalBooking"> | number
    totalAmount?: IntWithAggregatesFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"FestivalBooking"> | string | null
    status?: StringWithAggregatesFilter<"FestivalBooking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FestivalBooking"> | Date | string
  }

  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    location?: StringFilter<"Hotel"> | string
    address?: StringFilter<"Hotel"> | string
    imageUrl?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    category?: StringFilter<"Hotel"> | string
    starRating?: IntFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntFilter<"Hotel"> | number
    isActive?: BoolFilter<"Hotel"> | boolean
    contactEmail?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    checkInTime?: StringFilter<"Hotel"> | string
    checkOutTime?: StringFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    rooms?: HotelRoomListRelationFilter
    bookings?: HotelBookingListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    category?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rooms?: HotelRoomOrderByRelationAggregateInput
    bookings?: HotelBookingOrderByRelationAggregateInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    location?: StringFilter<"Hotel"> | string
    address?: StringFilter<"Hotel"> | string
    imageUrl?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    category?: StringFilter<"Hotel"> | string
    starRating?: IntFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntFilter<"Hotel"> | number
    isActive?: BoolFilter<"Hotel"> | boolean
    contactEmail?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    checkInTime?: StringFilter<"Hotel"> | string
    checkOutTime?: StringFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    rooms?: HotelRoomListRelationFilter
    bookings?: HotelBookingListRelationFilter
  }, "id">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    category?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hotel"> | number
    name?: StringWithAggregatesFilter<"Hotel"> | string
    description?: StringWithAggregatesFilter<"Hotel"> | string
    location?: StringWithAggregatesFilter<"Hotel"> | string
    address?: StringWithAggregatesFilter<"Hotel"> | string
    imageUrl?: StringWithAggregatesFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    category?: StringWithAggregatesFilter<"Hotel"> | string
    starRating?: IntWithAggregatesFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntWithAggregatesFilter<"Hotel"> | number
    isActive?: BoolWithAggregatesFilter<"Hotel"> | boolean
    contactEmail?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    website?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    checkInTime?: StringWithAggregatesFilter<"Hotel"> | string
    checkOutTime?: StringWithAggregatesFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
  }

  export type HotelRoomWhereInput = {
    AND?: HotelRoomWhereInput | HotelRoomWhereInput[]
    OR?: HotelRoomWhereInput[]
    NOT?: HotelRoomWhereInput | HotelRoomWhereInput[]
    id?: IntFilter<"HotelRoom"> | number
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    bookings?: HotelBookingListRelationFilter
  }

  export type HotelRoomOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    bookings?: HotelBookingOrderByRelationAggregateInput
  }

  export type HotelRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelRoomWhereInput | HotelRoomWhereInput[]
    OR?: HotelRoomWhereInput[]
    NOT?: HotelRoomWhereInput | HotelRoomWhereInput[]
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    bookings?: HotelBookingListRelationFilter
  }, "id">

  export type HotelRoomOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
    _count?: HotelRoomCountOrderByAggregateInput
    _avg?: HotelRoomAvgOrderByAggregateInput
    _max?: HotelRoomMaxOrderByAggregateInput
    _min?: HotelRoomMinOrderByAggregateInput
    _sum?: HotelRoomSumOrderByAggregateInput
  }

  export type HotelRoomScalarWhereWithAggregatesInput = {
    AND?: HotelRoomScalarWhereWithAggregatesInput | HotelRoomScalarWhereWithAggregatesInput[]
    OR?: HotelRoomScalarWhereWithAggregatesInput[]
    NOT?: HotelRoomScalarWhereWithAggregatesInput | HotelRoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelRoom"> | number
    hotelId?: IntWithAggregatesFilter<"HotelRoom"> | number
    roomType?: StringWithAggregatesFilter<"HotelRoom"> | string
    roomName?: StringWithAggregatesFilter<"HotelRoom"> | string
    description?: StringWithAggregatesFilter<"HotelRoom"> | string
    imageUrl?: StringWithAggregatesFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntWithAggregatesFilter<"HotelRoom"> | number
    bedType?: StringWithAggregatesFilter<"HotelRoom"> | string
    roomSize?: StringNullableWithAggregatesFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntWithAggregatesFilter<"HotelRoom"> | number
    totalRooms?: IntWithAggregatesFilter<"HotelRoom"> | number
    isActive?: BoolWithAggregatesFilter<"HotelRoom"> | boolean
  }

  export type HotelBookingWhereInput = {
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    id?: IntFilter<"HotelBooking"> | number
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    room?: XOR<HotelRoomRelationFilter, HotelRoomWhereInput>
  }

  export type HotelBookingOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    room?: HotelRoomOrderByWithRelationInput
  }

  export type HotelBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    room?: XOR<HotelRoomRelationFilter, HotelRoomWhereInput>
  }, "id">

  export type HotelBookingOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    _count?: HotelBookingCountOrderByAggregateInput
    _avg?: HotelBookingAvgOrderByAggregateInput
    _max?: HotelBookingMaxOrderByAggregateInput
    _min?: HotelBookingMinOrderByAggregateInput
    _sum?: HotelBookingSumOrderByAggregateInput
  }

  export type HotelBookingScalarWhereWithAggregatesInput = {
    AND?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    OR?: HotelBookingScalarWhereWithAggregatesInput[]
    NOT?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelBooking"> | number
    hotelId?: IntWithAggregatesFilter<"HotelBooking"> | number
    roomId?: IntWithAggregatesFilter<"HotelBooking"> | number
    firstName?: StringWithAggregatesFilter<"HotelBooking"> | string
    lastName?: StringWithAggregatesFilter<"HotelBooking"> | string
    email?: StringWithAggregatesFilter<"HotelBooking"> | string
    phone?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntWithAggregatesFilter<"HotelBooking"> | number
    numberOfGuests?: IntWithAggregatesFilter<"HotelBooking"> | number
    totalAmount?: IntWithAggregatesFilter<"HotelBooking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    status?: StringWithAggregatesFilter<"HotelBooking"> | string
    paymentStatus?: StringWithAggregatesFilter<"HotelBooking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
  }

  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    id?: IntFilter<"UserAccount"> | number
    email?: StringFilter<"UserAccount"> | string
    password?: StringFilter<"UserAccount"> | string
    firstName?: StringFilter<"UserAccount"> | string
    lastName?: StringFilter<"UserAccount"> | string
    phone?: StringNullableFilter<"UserAccount"> | string | null
    role?: StringFilter<"UserAccount"> | string
    isActive?: BoolFilter<"UserAccount"> | boolean
    profileImage?: StringNullableFilter<"UserAccount"> | string | null
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    feedbacks?: UserFeedbackListRelationFilter
  }

  export type UserAccountOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    feedbacks?: UserFeedbackOrderByRelationAggregateInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    password?: StringFilter<"UserAccount"> | string
    firstName?: StringFilter<"UserAccount"> | string
    lastName?: StringFilter<"UserAccount"> | string
    phone?: StringNullableFilter<"UserAccount"> | string | null
    role?: StringFilter<"UserAccount"> | string
    isActive?: BoolFilter<"UserAccount"> | boolean
    profileImage?: StringNullableFilter<"UserAccount"> | string | null
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    feedbacks?: UserFeedbackListRelationFilter
  }, "id" | "email">

  export type UserAccountOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _avg?: UserAccountAvgOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
    _sum?: UserAccountSumOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAccount"> | number
    email?: StringWithAggregatesFilter<"UserAccount"> | string
    password?: StringWithAggregatesFilter<"UserAccount"> | string
    firstName?: StringWithAggregatesFilter<"UserAccount"> | string
    lastName?: StringWithAggregatesFilter<"UserAccount"> | string
    phone?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    role?: StringWithAggregatesFilter<"UserAccount"> | string
    isActive?: BoolWithAggregatesFilter<"UserAccount"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"UserAccount"> | Date | string | null
  }

  export type UserFeedbackWhereInput = {
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    id?: IntFilter<"UserFeedback"> | number
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    itinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    tour?: XOR<TourNullableRelationFilter, TourWhereInput> | null
  }

  export type UserFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrderInput | SortOrder
    tourId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    user?: UserAccountOrderByWithRelationInput
    itinerary?: ItineraryOrderByWithRelationInput
    tour?: TourOrderByWithRelationInput
  }

  export type UserFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    itinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    tour?: XOR<TourNullableRelationFilter, TourWhereInput> | null
  }, "id">

  export type UserFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrderInput | SortOrder
    tourId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    _count?: UserFeedbackCountOrderByAggregateInput
    _avg?: UserFeedbackAvgOrderByAggregateInput
    _max?: UserFeedbackMaxOrderByAggregateInput
    _min?: UserFeedbackMinOrderByAggregateInput
    _sum?: UserFeedbackSumOrderByAggregateInput
  }

  export type UserFeedbackScalarWhereWithAggregatesInput = {
    AND?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    OR?: UserFeedbackScalarWhereWithAggregatesInput[]
    NOT?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserFeedback"> | number
    userId?: IntWithAggregatesFilter<"UserFeedback"> | number
    itineraryId?: IntNullableWithAggregatesFilter<"UserFeedback"> | number | null
    tourId?: IntNullableWithAggregatesFilter<"UserFeedback"> | number | null
    rating?: IntWithAggregatesFilter<"UserFeedback"> | number
    comment?: StringNullableWithAggregatesFilter<"UserFeedback"> | string | null
    category?: StringWithAggregatesFilter<"UserFeedback"> | string
    isPublic?: BoolWithAggregatesFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserFeedback"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TourCreateInput = {
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    TourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    TourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourCreateManyInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    tourOperatorId?: number | null
  }

  export type TourUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
  }

  export type TourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUncheckedCreateInput = {
    id?: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialCreateManyInput = {
    id?: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostCreateInput = {
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUncheckedCreateInput = {
    id?: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostCreateManyInput = {
    id?: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuideCreateInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryCreateNestedManyWithoutGuideInput
    drivenItineraries?: ItineraryCreateNestedManyWithoutDriverInput
  }

  export type GuideUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryUncheckedCreateNestedManyWithoutGuideInput
    drivenItineraries?: ItineraryUncheckedCreateNestedManyWithoutDriverInput
  }

  export type GuideUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUpdateManyWithoutGuideNestedInput
    drivenItineraries?: ItineraryUpdateManyWithoutDriverNestedInput
  }

  export type GuideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUncheckedUpdateManyWithoutGuideNestedInput
    drivenItineraries?: ItineraryUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type GuideCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
  }

  export type GuideUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryCreateInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateManyInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryDayCreateInput = {
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
    itinerary: ItineraryCreateNestedOneWithoutDaysInput
  }

  export type ItineraryDayUncheckedCreateInput = {
    id?: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUpdateInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: ItineraryUpdateOneRequiredWithoutDaysNestedInput
  }

  export type ItineraryDayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayCreateManyInput = {
    id?: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUpdateManyMutationInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomTourRequestCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
    assignedItinerary?: ItineraryCreateNestedOneWithoutAssignedCustomTourRequestsInput
  }

  export type CustomTourRequestUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    assignedItineraryId?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedItinerary?: ItineraryUpdateOneWithoutAssignedCustomTourRequestsNestedInput
  }

  export type CustomTourRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    assignedItineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourRequestCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    assignedItineraryId?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    assignedItineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorCreateInput = {
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
    tours?: TourCreateNestedManyWithoutTourOperatorInput
  }

  export type TourOperatorUncheckedCreateInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
    tours?: TourUncheckedCreateNestedManyWithoutTourOperatorInput
  }

  export type TourOperatorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUpdateManyWithoutTourOperatorNestedInput
  }

  export type TourOperatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUncheckedUpdateManyWithoutTourOperatorNestedInput
  }

  export type TourOperatorCreateManyInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalCreateInput = {
    name: string
    description: string
    location: string
    startDate: Date | string
    endDate: Date | string
    imageUrl: string
    category: string
    highlights?: FestivalCreatehighlightsInput | string[]
    isActive?: boolean
    ticketPrice?: number | null
    maxCapacity?: number | null
    createdAt?: Date | string
    bookings?: FestivalBookingCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    location: string
    startDate: Date | string
    endDate: Date | string
    imageUrl: string
    category: string
    highlights?: FestivalCreatehighlightsInput | string[]
    isActive?: boolean
    ticketPrice?: number | null
    maxCapacity?: number | null
    createdAt?: Date | string
    bookings?: FestivalBookingUncheckedCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: FestivalBookingUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: FestivalBookingUncheckedUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalCreateManyInput = {
    id?: number
    name: string
    description: string
    location: string
    startDate: Date | string
    endDate: Date | string
    imageUrl: string
    category: string
    highlights?: FestivalCreatehighlightsInput | string[]
    isActive?: boolean
    ticketPrice?: number | null
    maxCapacity?: number | null
    createdAt?: Date | string
  }

  export type FestivalUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    festival: FestivalCreateNestedOneWithoutBookingsInput
  }

  export type FestivalBookingUncheckedCreateInput = {
    id?: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    festival?: FestivalUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type FestivalBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingCreateManyInput = {
    id?: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCreateInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
  }

  export type HotelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRoomCreateInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    hotel: HotelCreateNestedOneWithoutRoomsInput
    bookings?: HotelBookingCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUncheckedCreateInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUpdateInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
    bookings?: HotelBookingUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomCreateManyInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelRoomUpdateManyMutationInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelRoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelBookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    hotel: HotelCreateNestedOneWithoutBookingsInput
    room: HotelRoomCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateInput = {
    id?: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    room?: HotelRoomUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingCreateManyInput = {
    id?: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserAccountUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAccountUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAccountCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserAccountUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeedbackCreateInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateManyInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type TourOperatorNullableRelationFilter = {
    is?: TourOperatorWhereInput | null
    isNot?: TourOperatorWhereInput | null
  }

  export type UserFeedbackListRelationFilter = {
    every?: UserFeedbackWhereInput
    some?: UserFeedbackWhereInput
    none?: UserFeedbackWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    maxGroupSize?: SortOrder
    difficulty?: SortOrder
    bestSeason?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    maxGroupSize?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    isActive?: SortOrder
    maxGroupSize?: SortOrder
    difficulty?: SortOrder
    bestSeason?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    isActive?: SortOrder
    maxGroupSize?: SortOrder
    difficulty?: SortOrder
    bestSeason?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    maxGroupSize?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TourRelationFilter = {
    is?: TourWhereInput
    isNot?: TourWhereInput
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    groupSize?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    groupSize?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideNullableRelationFilter = {
    is?: GuideWhereInput | null
    isNot?: GuideWhereInput | null
  }

  export type ItineraryDayListRelationFilter = {
    every?: ItineraryDayWhereInput
    some?: ItineraryDayWhereInput
    none?: ItineraryDayWhereInput
  }

  export type CustomTourRequestListRelationFilter = {
    every?: CustomTourRequestWhereInput
    some?: CustomTourRequestWhereInput
    none?: CustomTourRequestWhereInput
  }

  export type ItineraryDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomTourRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItineraryAvgOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItinerarySumOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
  }

  export type ItineraryRelationFilter = {
    is?: ItineraryWhereInput
    isNot?: ItineraryWhereInput
  }

  export type ItineraryDayCountOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrder
    meals?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDayAvgOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
  }

  export type ItineraryDayMaxOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    accommodation?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDayMinOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    accommodation?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDaySumOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
  }

  export type ItineraryNullableRelationFilter = {
    is?: ItineraryWhereInput | null
    isNot?: ItineraryWhereInput | null
  }

  export type CustomTourRequestCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    interests?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
  }

  export type CustomTourRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
  }

  export type TourListRelationFilter = {
    every?: TourWhereInput
    some?: TourWhereInput
    none?: TourWhereInput
  }

  export type TourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourOperatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    establishedYear?: SortOrder
  }

  export type TourOperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    establishedYear?: SortOrder
  }

  export type FestivalBookingListRelationFilter = {
    every?: FestivalBookingWhereInput
    some?: FestivalBookingWhereInput
    none?: FestivalBookingWhereInput
  }

  export type FestivalBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FestivalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    highlights?: SortOrder
    isActive?: SortOrder
    ticketPrice?: SortOrder
    maxCapacity?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketPrice?: SortOrder
    maxCapacity?: SortOrder
  }

  export type FestivalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    ticketPrice?: SortOrder
    maxCapacity?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    ticketPrice?: SortOrder
    maxCapacity?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalSumOrderByAggregateInput = {
    id?: SortOrder
    ticketPrice?: SortOrder
    maxCapacity?: SortOrder
  }

  export type FestivalRelationFilter = {
    is?: FestivalWhereInput
    isNot?: FestivalWhereInput
  }

  export type FestivalBookingCountOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
  }

  export type FestivalBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingMinOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingSumOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
  }

  export type HotelRoomListRelationFilter = {
    every?: HotelRoomWhereInput
    some?: HotelRoomWhereInput
    none?: HotelRoomWhereInput
  }

  export type HotelBookingListRelationFilter = {
    every?: HotelBookingWhereInput
    some?: HotelBookingWhereInput
    none?: HotelBookingWhereInput
  }

  export type HotelRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    category?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    id?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    id?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
  }

  export type HotelRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type HotelRoomCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxOccupancy?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
  }

  export type HotelRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxOccupancy?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
  }

  export type HotelRoomRelationFilter = {
    is?: HotelRoomWhereInput
    isNot?: HotelRoomWhereInput
  }

  export type HotelBookingCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
  }

  export type HotelBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserAccountCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserAccountRelationFilter = {
    is?: UserAccountWhereInput
    isNot?: UserAccountWhereInput
  }

  export type TourNullableRelationFilter = {
    is?: TourWhereInput | null
    isNot?: TourWhereInput | null
  }

  export type UserFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
  }

  export type UserFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TourCreatehighlightsInput = {
    set: string[]
  }

  export type TourCreateincludesInput = {
    set: string[]
  }

  export type TourCreateexcludesInput = {
    set: string[]
  }

  export type BookingCreateNestedManyWithoutTourInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutTourInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type TourOperatorCreateNestedOneWithoutToursInput = {
    create?: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    connectOrCreate?: TourOperatorCreateOrConnectWithoutToursInput
    connect?: TourOperatorWhereUniqueInput
  }

  export type UserFeedbackCreateNestedManyWithoutTourInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TourUpdatehighlightsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TourUpdateincludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateexcludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BookingUpdateManyWithoutTourNestedInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTourInput | BookingUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTourInput | BookingUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTourInput | BookingUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutTourNestedInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutTourInput | ItineraryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutTourInput | ItineraryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutTourInput | ItineraryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type TourOperatorUpdateOneWithoutToursNestedInput = {
    create?: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    connectOrCreate?: TourOperatorCreateOrConnectWithoutToursInput
    upsert?: TourOperatorUpsertWithoutToursInput
    disconnect?: TourOperatorWhereInput | boolean
    delete?: TourOperatorWhereInput | boolean
    connect?: TourOperatorWhereUniqueInput
    update?: XOR<XOR<TourOperatorUpdateToOneWithWhereWithoutToursInput, TourOperatorUpdateWithoutToursInput>, TourOperatorUncheckedUpdateWithoutToursInput>
  }

  export type UserFeedbackUpdateManyWithoutTourNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutTourInput | UserFeedbackUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutTourInput | UserFeedbackUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutTourInput | UserFeedbackUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTourInput | BookingUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTourInput | BookingUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTourInput | BookingUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutTourInput | ItineraryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutTourInput | ItineraryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutTourInput | ItineraryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutTourInput | UserFeedbackUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutTourInput | UserFeedbackUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutTourInput | UserFeedbackUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TourCreateOrConnectWithoutBookingsInput
    connect?: TourWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TourUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TourCreateOrConnectWithoutBookingsInput
    upsert?: TourUpsertWithoutBookingsInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutBookingsInput, TourUpdateWithoutBookingsInput>, TourUncheckedUpdateWithoutBookingsInput>
  }

  export type GuideCreatespecializationsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedManyWithoutGuideInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutDriverInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutGuideInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type GuideUpdatespecializationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateManyWithoutGuideNestedInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutGuideInput | ItineraryUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutGuideInput | ItineraryUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutGuideInput | ItineraryUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutDriverInput | ItineraryUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutDriverInput | ItineraryUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutDriverInput | ItineraryUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutGuideNestedInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutGuideInput | ItineraryUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutGuideInput | ItineraryUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutGuideInput | ItineraryUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutDriverInput | ItineraryUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutDriverInput | ItineraryUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutDriverInput | ItineraryUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutItinerariesInput = {
    create?: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: TourCreateOrConnectWithoutItinerariesInput
    connect?: TourWhereUniqueInput
  }

  export type GuideCreateNestedOneWithoutGuidedItinerariesInput = {
    create?: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutGuidedItinerariesInput
    connect?: GuideWhereUniqueInput
  }

  export type GuideCreateNestedOneWithoutDrivenItinerariesInput = {
    create?: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutDrivenItinerariesInput
    connect?: GuideWhereUniqueInput
  }

  export type ItineraryDayCreateNestedManyWithoutItineraryInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
  }

  export type CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
  }

  export type UserFeedbackCreateNestedManyWithoutItineraryInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
  }

  export type CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type TourUpdateOneRequiredWithoutItinerariesNestedInput = {
    create?: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: TourCreateOrConnectWithoutItinerariesInput
    upsert?: TourUpsertWithoutItinerariesInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutItinerariesInput, TourUpdateWithoutItinerariesInput>, TourUncheckedUpdateWithoutItinerariesInput>
  }

  export type GuideUpdateOneWithoutGuidedItinerariesNestedInput = {
    create?: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutGuidedItinerariesInput
    upsert?: GuideUpsertWithoutGuidedItinerariesInput
    disconnect?: GuideWhereInput | boolean
    delete?: GuideWhereInput | boolean
    connect?: GuideWhereUniqueInput
    update?: XOR<XOR<GuideUpdateToOneWithWhereWithoutGuidedItinerariesInput, GuideUpdateWithoutGuidedItinerariesInput>, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
  }

  export type GuideUpdateOneWithoutDrivenItinerariesNestedInput = {
    create?: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutDrivenItinerariesInput
    upsert?: GuideUpsertWithoutDrivenItinerariesInput
    disconnect?: GuideWhereInput | boolean
    delete?: GuideWhereInput | boolean
    connect?: GuideWhereUniqueInput
    update?: XOR<XOR<GuideUpdateToOneWithWhereWithoutDrivenItinerariesInput, GuideUpdateWithoutDrivenItinerariesInput>, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
  }

  export type ItineraryDayUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    upsert?: ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput | ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    set?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    disconnect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    delete?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    update?: ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput | ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: ItineraryDayUpdateManyWithWhereWithoutItineraryInput | ItineraryDayUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
  }

  export type CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    upsert?: CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    set?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    disconnect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    delete?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    update?: CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput[]
    updateMany?: CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput | CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput[]
    deleteMany?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
  }

  export type UserFeedbackUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput | UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput | UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutItineraryInput | UserFeedbackUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    upsert?: ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput | ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    set?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    disconnect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    delete?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    update?: ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput | ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: ItineraryDayUpdateManyWithWhereWithoutItineraryInput | ItineraryDayUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
  }

  export type CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    upsert?: CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    set?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    disconnect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    delete?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    update?: CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput[]
    updateMany?: CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput | CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput[]
    deleteMany?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput | UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput | UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutItineraryInput | UserFeedbackUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type ItineraryDayCreateactivitiesInput = {
    set: string[]
  }

  export type ItineraryDayCreatemealsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedOneWithoutDaysInput = {
    create?: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutDaysInput
    connect?: ItineraryWhereUniqueInput
  }

  export type ItineraryDayUpdateactivitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryDayUpdatemealsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateOneRequiredWithoutDaysNestedInput = {
    create?: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutDaysInput
    upsert?: ItineraryUpsertWithoutDaysInput
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutDaysInput, ItineraryUpdateWithoutDaysInput>, ItineraryUncheckedUpdateWithoutDaysInput>
  }

  export type CustomTourRequestCreateinterestsInput = {
    set: string[]
  }

  export type CustomTourRequestCreatedestinationsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedOneWithoutAssignedCustomTourRequestsInput = {
    create?: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput
    connect?: ItineraryWhereUniqueInput
  }

  export type CustomTourRequestUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomTourRequestUpdatedestinationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateOneWithoutAssignedCustomTourRequestsNestedInput = {
    create?: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput
    upsert?: ItineraryUpsertWithoutAssignedCustomTourRequestsInput
    disconnect?: ItineraryWhereInput | boolean
    delete?: ItineraryWhereInput | boolean
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutAssignedCustomTourRequestsInput, ItineraryUpdateWithoutAssignedCustomTourRequestsInput>, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
  }

  export type TourOperatorCreatespecialtiesInput = {
    set: string[]
  }

  export type TourOperatorCreatecertificationsInput = {
    set: string[]
  }

  export type TourOperatorCreateawardsInput = {
    set: string[]
  }

  export type TourCreateNestedManyWithoutTourOperatorInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutTourOperatorInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourOperatorUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourOperatorUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourOperatorUpdateawardsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateManyWithoutTourOperatorNestedInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutTourOperatorInput | TourUpsertWithWhereUniqueWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutTourOperatorInput | TourUpdateWithWhereUniqueWithoutTourOperatorInput[]
    updateMany?: TourUpdateManyWithWhereWithoutTourOperatorInput | TourUpdateManyWithWhereWithoutTourOperatorInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutTourOperatorNestedInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutTourOperatorInput | TourUpsertWithWhereUniqueWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutTourOperatorInput | TourUpdateWithWhereUniqueWithoutTourOperatorInput[]
    updateMany?: TourUpdateManyWithWhereWithoutTourOperatorInput | TourUpdateManyWithWhereWithoutTourOperatorInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type FestivalCreatehighlightsInput = {
    set: string[]
  }

  export type FestivalBookingCreateNestedManyWithoutFestivalInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
  }

  export type FestivalBookingUncheckedCreateNestedManyWithoutFestivalInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
  }

  export type FestivalUpdatehighlightsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FestivalBookingUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    upsert?: FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput | FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    set?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    disconnect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    delete?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    update?: FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput | FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: FestivalBookingUpdateManyWithWhereWithoutFestivalInput | FestivalBookingUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
  }

  export type FestivalBookingUncheckedUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    upsert?: FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput | FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    set?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    disconnect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    delete?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    update?: FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput | FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: FestivalBookingUpdateManyWithWhereWithoutFestivalInput | FestivalBookingUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
  }

  export type FestivalCreateNestedOneWithoutBookingsInput = {
    create?: XOR<FestivalCreateWithoutBookingsInput, FestivalUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutBookingsInput
    connect?: FestivalWhereUniqueInput
  }

  export type FestivalUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<FestivalCreateWithoutBookingsInput, FestivalUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutBookingsInput
    upsert?: FestivalUpsertWithoutBookingsInput
    connect?: FestivalWhereUniqueInput
    update?: XOR<XOR<FestivalUpdateToOneWithWhereWithoutBookingsInput, FestivalUpdateWithoutBookingsInput>, FestivalUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelCreateimagesInput = {
    set: string[]
  }

  export type HotelCreateamenitiesInput = {
    set: string[]
  }

  export type HotelCreatefeaturesInput = {
    set: string[]
  }

  export type HotelRoomCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
  }

  export type HotelBookingCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelRoomUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelRoomUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    upsert?: HotelRoomUpsertWithWhereUniqueWithoutHotelInput | HotelRoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    set?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    disconnect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    delete?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    update?: HotelRoomUpdateWithWhereUniqueWithoutHotelInput | HotelRoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelRoomUpdateManyWithWhereWithoutHotelInput | HotelRoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
  }

  export type HotelBookingUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutHotelInput | HotelBookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutHotelInput | HotelBookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutHotelInput | HotelBookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelRoomUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    upsert?: HotelRoomUpsertWithWhereUniqueWithoutHotelInput | HotelRoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    set?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    disconnect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    delete?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    update?: HotelRoomUpdateWithWhereUniqueWithoutHotelInput | HotelRoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelRoomUpdateManyWithWhereWithoutHotelInput | HotelRoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
  }

  export type HotelBookingUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutHotelInput | HotelBookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutHotelInput | HotelBookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutHotelInput | HotelBookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelRoomCreateimagesInput = {
    set: string[]
  }

  export type HotelRoomCreateamenitiesInput = {
    set: string[]
  }

  export type HotelCreateNestedOneWithoutRoomsInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelBookingCreateNestedManyWithoutRoomInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelRoomUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelRoomUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    upsert?: HotelUpsertWithoutRoomsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomsInput, HotelUpdateWithoutRoomsInput>, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelBookingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRoomInput | HotelBookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRoomInput | HotelBookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRoomInput | HotelBookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelBookingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRoomInput | HotelBookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRoomInput | HotelBookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRoomInput | HotelBookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelRoomCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelRoomCreateOrConnectWithoutBookingsInput
    connect?: HotelRoomWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    upsert?: HotelUpsertWithoutBookingsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutBookingsInput, HotelUpdateWithoutBookingsInput>, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelRoomUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelRoomCreateOrConnectWithoutBookingsInput
    upsert?: HotelRoomUpsertWithoutBookingsInput
    connect?: HotelRoomWhereUniqueInput
    update?: XOR<XOR<HotelRoomUpdateToOneWithWhereWithoutBookingsInput, HotelRoomUpdateWithoutBookingsInput>, HotelRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type UserFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutUserInput | UserFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutUserInput | UserFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutUserInput | UserFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutUserInput | UserFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutUserInput | UserFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutUserInput | UserFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type UserAccountCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutFeedbacksInput
    connect?: UserAccountWhereUniqueInput
  }

  export type ItineraryCreateNestedOneWithoutUserFeedbackInput = {
    create?: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutUserFeedbackInput
    connect?: ItineraryWhereUniqueInput
  }

  export type TourCreateNestedOneWithoutUserFeedbackInput = {
    create?: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: TourCreateOrConnectWithoutUserFeedbackInput
    connect?: TourWhereUniqueInput
  }

  export type UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutFeedbacksInput
    upsert?: UserAccountUpsertWithoutFeedbacksInput
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutFeedbacksInput, UserAccountUpdateWithoutFeedbacksInput>, UserAccountUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ItineraryUpdateOneWithoutUserFeedbackNestedInput = {
    create?: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutUserFeedbackInput
    upsert?: ItineraryUpsertWithoutUserFeedbackInput
    disconnect?: ItineraryWhereInput | boolean
    delete?: ItineraryWhereInput | boolean
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutUserFeedbackInput, ItineraryUpdateWithoutUserFeedbackInput>, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type TourUpdateOneWithoutUserFeedbackNestedInput = {
    create?: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: TourCreateOrConnectWithoutUserFeedbackInput
    upsert?: TourUpsertWithoutUserFeedbackInput
    disconnect?: TourWhereInput | boolean
    delete?: TourWhereInput | boolean
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutUserFeedbackInput, TourUpdateWithoutUserFeedbackInput>, TourUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BookingCreateWithoutTourInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingUncheckedCreateWithoutTourInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutTourInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput>
  }

  export type BookingCreateManyTourInputEnvelope = {
    data: BookingCreateManyTourInput | BookingCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutTourInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutTourInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput>
  }

  export type ItineraryCreateManyTourInputEnvelope = {
    data: ItineraryCreateManyTourInput | ItineraryCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type TourOperatorCreateWithoutToursInput = {
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorUncheckedCreateWithoutToursInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorCreateOrConnectWithoutToursInput = {
    where: TourOperatorWhereUniqueInput
    create: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
  }

  export type UserFeedbackCreateWithoutTourInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutTourInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput>
  }

  export type UserFeedbackCreateManyTourInputEnvelope = {
    data: UserFeedbackCreateManyTourInput | UserFeedbackCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutTourInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTourInput, BookingUncheckedUpdateWithoutTourInput>
    create: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTourInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTourInput, BookingUncheckedUpdateWithoutTourInput>
  }

  export type BookingUpdateManyWithWhereWithoutTourInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTourInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ItineraryUpsertWithWhereUniqueWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutTourInput, ItineraryUncheckedUpdateWithoutTourInput>
    create: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutTourInput, ItineraryUncheckedUpdateWithoutTourInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutTourInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutTourInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    OR?: ItineraryScalarWhereInput[]
    NOT?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
  }

  export type TourOperatorUpsertWithoutToursInput = {
    update: XOR<TourOperatorUpdateWithoutToursInput, TourOperatorUncheckedUpdateWithoutToursInput>
    create: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    where?: TourOperatorWhereInput
  }

  export type TourOperatorUpdateToOneWithWhereWithoutToursInput = {
    where?: TourOperatorWhereInput
    data: XOR<TourOperatorUpdateWithoutToursInput, TourOperatorUncheckedUpdateWithoutToursInput>
  }

  export type TourOperatorUpdateWithoutToursInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorUncheckedUpdateWithoutToursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutTourInput, UserFeedbackUncheckedUpdateWithoutTourInput>
    create: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutTourInput, UserFeedbackUncheckedUpdateWithoutTourInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutTourInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutTourInput>
  }

  export type UserFeedbackScalarWhereInput = {
    AND?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
    OR?: UserFeedbackScalarWhereInput[]
    NOT?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
    id?: IntFilter<"UserFeedback"> | number
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
  }

  export type TourCreateWithoutBookingsInput = {
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    TourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    tourOperatorId?: number | null
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutBookingsInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
  }

  export type TourUpsertWithoutBookingsInput = {
    update: XOR<TourUpdateWithoutBookingsInput, TourUncheckedUpdateWithoutBookingsInput>
    create: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutBookingsInput, TourUncheckedUpdateWithoutBookingsInput>
  }

  export type TourUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    TourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
  }

  export type ItineraryCreateWithoutGuideInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutGuideInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput>
  }

  export type ItineraryCreateManyGuideInputEnvelope = {
    data: ItineraryCreateManyGuideInput | ItineraryCreateManyGuideInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutDriverInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutDriverInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput>
  }

  export type ItineraryCreateManyDriverInputEnvelope = {
    data: ItineraryCreateManyDriverInput | ItineraryCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryUpsertWithWhereUniqueWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutGuideInput, ItineraryUncheckedUpdateWithoutGuideInput>
    create: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutGuideInput, ItineraryUncheckedUpdateWithoutGuideInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutGuideInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutGuideInput>
  }

  export type ItineraryUpsertWithWhereUniqueWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutDriverInput, ItineraryUncheckedUpdateWithoutDriverInput>
    create: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutDriverInput, ItineraryUncheckedUpdateWithoutDriverInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutDriverInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutDriverInput>
  }

  export type TourCreateWithoutItinerariesInput = {
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    bookings?: BookingCreateNestedManyWithoutTourInput
    TourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutItinerariesInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutItinerariesInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
  }

  export type GuideCreateWithoutGuidedItinerariesInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    drivenItineraries?: ItineraryCreateNestedManyWithoutDriverInput
  }

  export type GuideUncheckedCreateWithoutGuidedItinerariesInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    drivenItineraries?: ItineraryUncheckedCreateNestedManyWithoutDriverInput
  }

  export type GuideCreateOrConnectWithoutGuidedItinerariesInput = {
    where: GuideWhereUniqueInput
    create: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
  }

  export type GuideCreateWithoutDrivenItinerariesInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryCreateNestedManyWithoutGuideInput
  }

  export type GuideUncheckedCreateWithoutDrivenItinerariesInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryUncheckedCreateNestedManyWithoutGuideInput
  }

  export type GuideCreateOrConnectWithoutDrivenItinerariesInput = {
    where: GuideWhereUniqueInput
    create: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
  }

  export type ItineraryDayCreateWithoutItineraryInput = {
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUncheckedCreateWithoutItineraryInput = {
    id?: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayCreateOrConnectWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    create: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput>
  }

  export type ItineraryDayCreateManyItineraryInputEnvelope = {
    data: ItineraryDayCreateManyItineraryInput | ItineraryDayCreateManyItineraryInput[]
    skipDuplicates?: boolean
  }

  export type CustomTourRequestCreateWithoutAssignedItineraryInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    create: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestCreateManyAssignedItineraryInputEnvelope = {
    data: CustomTourRequestCreateManyAssignedItineraryInput | CustomTourRequestCreateManyAssignedItineraryInput[]
    skipDuplicates?: boolean
  }

  export type UserFeedbackCreateWithoutItineraryInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutItineraryInput = {
    id?: number
    userId: number
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput>
  }

  export type UserFeedbackCreateManyItineraryInputEnvelope = {
    data: UserFeedbackCreateManyItineraryInput | UserFeedbackCreateManyItineraryInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithoutItinerariesInput = {
    update: XOR<TourUpdateWithoutItinerariesInput, TourUncheckedUpdateWithoutItinerariesInput>
    create: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutItinerariesInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutItinerariesInput, TourUncheckedUpdateWithoutItinerariesInput>
  }

  export type TourUpdateWithoutItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    bookings?: BookingUpdateManyWithoutTourNestedInput
    TourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
  }

  export type GuideUpsertWithoutGuidedItinerariesInput = {
    update: XOR<GuideUpdateWithoutGuidedItinerariesInput, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
    create: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    where?: GuideWhereInput
  }

  export type GuideUpdateToOneWithWhereWithoutGuidedItinerariesInput = {
    where?: GuideWhereInput
    data: XOR<GuideUpdateWithoutGuidedItinerariesInput, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
  }

  export type GuideUpdateWithoutGuidedItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivenItineraries?: ItineraryUpdateManyWithoutDriverNestedInput
  }

  export type GuideUncheckedUpdateWithoutGuidedItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivenItineraries?: ItineraryUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type GuideUpsertWithoutDrivenItinerariesInput = {
    update: XOR<GuideUpdateWithoutDrivenItinerariesInput, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
    create: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    where?: GuideWhereInput
  }

  export type GuideUpdateToOneWithWhereWithoutDrivenItinerariesInput = {
    where?: GuideWhereInput
    data: XOR<GuideUpdateWithoutDrivenItinerariesInput, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
  }

  export type GuideUpdateWithoutDrivenItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUpdateManyWithoutGuideNestedInput
  }

  export type GuideUncheckedUpdateWithoutDrivenItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUncheckedUpdateManyWithoutGuideNestedInput
  }

  export type ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    update: XOR<ItineraryDayUpdateWithoutItineraryInput, ItineraryDayUncheckedUpdateWithoutItineraryInput>
    create: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput>
  }

  export type ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    data: XOR<ItineraryDayUpdateWithoutItineraryInput, ItineraryDayUncheckedUpdateWithoutItineraryInput>
  }

  export type ItineraryDayUpdateManyWithWhereWithoutItineraryInput = {
    where: ItineraryDayScalarWhereInput
    data: XOR<ItineraryDayUpdateManyMutationInput, ItineraryDayUncheckedUpdateManyWithoutItineraryInput>
  }

  export type ItineraryDayScalarWhereInput = {
    AND?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
    OR?: ItineraryDayScalarWhereInput[]
    NOT?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
    id?: IntFilter<"ItineraryDay"> | number
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
  }

  export type CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    update: XOR<CustomTourRequestUpdateWithoutAssignedItineraryInput, CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput>
    create: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    data: XOR<CustomTourRequestUpdateWithoutAssignedItineraryInput, CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput = {
    where: CustomTourRequestScalarWhereInput
    data: XOR<CustomTourRequestUpdateManyMutationInput, CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestScalarWhereInput = {
    AND?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
    OR?: CustomTourRequestScalarWhereInput[]
    NOT?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
    id?: IntFilter<"CustomTourRequest"> | number
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    interests?: StringNullableListFilter<"CustomTourRequest">
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutItineraryInput, UserFeedbackUncheckedUpdateWithoutItineraryInput>
    create: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutItineraryInput, UserFeedbackUncheckedUpdateWithoutItineraryInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutItineraryInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutItineraryInput>
  }

  export type ItineraryCreateWithoutDaysInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutDaysInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutDaysInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
  }

  export type ItineraryUpsertWithoutDaysInput = {
    update: XOR<ItineraryUpdateWithoutDaysInput, ItineraryUncheckedUpdateWithoutDaysInput>
    create: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutDaysInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutDaysInput, ItineraryUncheckedUpdateWithoutDaysInput>
  }

  export type ItineraryUpdateWithoutDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateWithoutAssignedCustomTourRequestsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
  }

  export type ItineraryUpsertWithoutAssignedCustomTourRequestsInput = {
    update: XOR<ItineraryUpdateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
    create: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutAssignedCustomTourRequestsInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
  }

  export type ItineraryUpdateWithoutAssignedCustomTourRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type TourCreateWithoutTourOperatorInput = {
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutTourOperatorInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput>
  }

  export type TourCreateManyTourOperatorInputEnvelope = {
    data: TourCreateManyTourOperatorInput | TourCreateManyTourOperatorInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithWhereUniqueWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutTourOperatorInput, TourUncheckedUpdateWithoutTourOperatorInput>
    create: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput>
  }

  export type TourUpdateWithWhereUniqueWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutTourOperatorInput, TourUncheckedUpdateWithoutTourOperatorInput>
  }

  export type TourUpdateManyWithWhereWithoutTourOperatorInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutTourOperatorInput>
  }

  export type TourScalarWhereInput = {
    AND?: TourScalarWhereInput | TourScalarWhereInput[]
    OR?: TourScalarWhereInput[]
    NOT?: TourScalarWhereInput | TourScalarWhereInput[]
    id?: IntFilter<"Tour"> | number
    name?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    duration?: IntFilter<"Tour"> | number
    price?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    imageUrl?: StringFilter<"Tour"> | string
    rating?: FloatFilter<"Tour"> | number
    reviewCount?: IntFilter<"Tour"> | number
    highlights?: StringNullableListFilter<"Tour">
    isActive?: BoolFilter<"Tour"> | boolean
    maxGroupSize?: IntFilter<"Tour"> | number
    difficulty?: StringFilter<"Tour"> | string
    bestSeason?: StringFilter<"Tour"> | string
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
  }

  export type FestivalBookingCreateWithoutFestivalInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUncheckedCreateWithoutFestivalInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingCreateOrConnectWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    create: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput>
  }

  export type FestivalBookingCreateManyFestivalInputEnvelope = {
    data: FestivalBookingCreateManyFestivalInput | FestivalBookingCreateManyFestivalInput[]
    skipDuplicates?: boolean
  }

  export type FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    update: XOR<FestivalBookingUpdateWithoutFestivalInput, FestivalBookingUncheckedUpdateWithoutFestivalInput>
    create: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput>
  }

  export type FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    data: XOR<FestivalBookingUpdateWithoutFestivalInput, FestivalBookingUncheckedUpdateWithoutFestivalInput>
  }

  export type FestivalBookingUpdateManyWithWhereWithoutFestivalInput = {
    where: FestivalBookingScalarWhereInput
    data: XOR<FestivalBookingUpdateManyMutationInput, FestivalBookingUncheckedUpdateManyWithoutFestivalInput>
  }

  export type FestivalBookingScalarWhereInput = {
    AND?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
    OR?: FestivalBookingScalarWhereInput[]
    NOT?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
    id?: IntFilter<"FestivalBooking"> | number
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
  }

  export type FestivalCreateWithoutBookingsInput = {
    name: string
    description: string
    location: string
    startDate: Date | string
    endDate: Date | string
    imageUrl: string
    category: string
    highlights?: FestivalCreatehighlightsInput | string[]
    isActive?: boolean
    ticketPrice?: number | null
    maxCapacity?: number | null
    createdAt?: Date | string
  }

  export type FestivalUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description: string
    location: string
    startDate: Date | string
    endDate: Date | string
    imageUrl: string
    category: string
    highlights?: FestivalCreatehighlightsInput | string[]
    isActive?: boolean
    ticketPrice?: number | null
    maxCapacity?: number | null
    createdAt?: Date | string
  }

  export type FestivalCreateOrConnectWithoutBookingsInput = {
    where: FestivalWhereUniqueInput
    create: XOR<FestivalCreateWithoutBookingsInput, FestivalUncheckedCreateWithoutBookingsInput>
  }

  export type FestivalUpsertWithoutBookingsInput = {
    update: XOR<FestivalUpdateWithoutBookingsInput, FestivalUncheckedUpdateWithoutBookingsInput>
    create: XOR<FestivalCreateWithoutBookingsInput, FestivalUncheckedCreateWithoutBookingsInput>
    where?: FestivalWhereInput
  }

  export type FestivalUpdateToOneWithWhereWithoutBookingsInput = {
    where?: FestivalWhereInput
    data: XOR<FestivalUpdateWithoutBookingsInput, FestivalUncheckedUpdateWithoutBookingsInput>
  }

  export type FestivalUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    highlights?: FestivalUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ticketPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRoomCreateWithoutHotelInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUncheckedCreateWithoutHotelInput = {
    id?: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomCreateOrConnectWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    create: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput>
  }

  export type HotelRoomCreateManyHotelInputEnvelope = {
    data: HotelRoomCreateManyHotelInput | HotelRoomCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelBookingCreateWithoutHotelInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    room: HotelRoomCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutHotelInput = {
    id?: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingCreateOrConnectWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput>
  }

  export type HotelBookingCreateManyHotelInputEnvelope = {
    data: HotelBookingCreateManyHotelInput | HotelBookingCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelRoomUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    update: XOR<HotelRoomUpdateWithoutHotelInput, HotelRoomUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput>
  }

  export type HotelRoomUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    data: XOR<HotelRoomUpdateWithoutHotelInput, HotelRoomUncheckedUpdateWithoutHotelInput>
  }

  export type HotelRoomUpdateManyWithWhereWithoutHotelInput = {
    where: HotelRoomScalarWhereInput
    data: XOR<HotelRoomUpdateManyMutationInput, HotelRoomUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelRoomScalarWhereInput = {
    AND?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
    OR?: HotelRoomScalarWhereInput[]
    NOT?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
    id?: IntFilter<"HotelRoom"> | number
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutHotelInput, HotelBookingUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutHotelInput, HotelBookingUncheckedUpdateWithoutHotelInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutHotelInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelBookingScalarWhereInput = {
    AND?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    OR?: HotelBookingScalarWhereInput[]
    NOT?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    id?: IntFilter<"HotelBooking"> | number
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
  }

  export type HotelCreateWithoutRoomsInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    bookings?: HotelBookingCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
  }

  export type HotelBookingCreateWithoutRoomInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    hotel: HotelCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutRoomInput = {
    id?: number
    hotelId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingCreateOrConnectWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput>
  }

  export type HotelBookingCreateManyRoomInputEnvelope = {
    data: HotelBookingCreateManyRoomInput | HotelBookingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type HotelUpsertWithoutRoomsInput = {
    update: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: HotelBookingUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: HotelBookingUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutRoomInput, HotelBookingUncheckedUpdateWithoutRoomInput>
    create: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutRoomInput, HotelBookingUncheckedUpdateWithoutRoomInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutRoomInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutRoomInput>
  }

  export type HotelCreateWithoutBookingsInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    category: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutBookingsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
  }

  export type HotelRoomCreateWithoutBookingsInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    hotel: HotelCreateNestedOneWithoutRoomsInput
  }

  export type HotelRoomUncheckedCreateWithoutBookingsInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelRoomCreateOrConnectWithoutBookingsInput = {
    where: HotelRoomWhereUniqueInput
    create: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
  }

  export type HotelUpsertWithoutBookingsInput = {
    update: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    category?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelRoomUpsertWithoutBookingsInput = {
    update: XOR<HotelRoomUpdateWithoutBookingsInput, HotelRoomUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    where?: HotelRoomWhereInput
  }

  export type HotelRoomUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelRoomWhereInput
    data: XOR<HotelRoomUpdateWithoutBookingsInput, HotelRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelRoomUpdateWithoutBookingsInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type HotelRoomUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeedbackCreateWithoutUserInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput>
  }

  export type UserFeedbackCreateManyUserInputEnvelope = {
    data: UserFeedbackCreateManyUserInput | UserFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutUserInput, UserFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutUserInput, UserFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAccountCreateWithoutFeedbacksInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserAccountUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserAccountCreateOrConnectWithoutFeedbacksInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
  }

  export type ItineraryCreateWithoutUserFeedbackInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutUserFeedbackInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutUserFeedbackInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
  }

  export type TourCreateWithoutUserFeedbackInput = {
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    TourOperator?: TourOperatorCreateNestedOneWithoutToursInput
  }

  export type TourUncheckedCreateWithoutUserFeedbackInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutUserFeedbackInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
  }

  export type UserAccountUpsertWithoutFeedbacksInput = {
    update: XOR<UserAccountUpdateWithoutFeedbacksInput, UserAccountUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutFeedbacksInput, UserAccountUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserAccountUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItineraryUpsertWithoutUserFeedbackInput = {
    update: XOR<ItineraryUpdateWithoutUserFeedbackInput, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
    create: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutUserFeedbackInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutUserFeedbackInput, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type ItineraryUpdateWithoutUserFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutUserFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
  }

  export type TourUpsertWithoutUserFeedbackInput = {
    update: XOR<TourUpdateWithoutUserFeedbackInput, TourUncheckedUpdateWithoutUserFeedbackInput>
    create: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutUserFeedbackInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutUserFeedbackInput, TourUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type TourUpdateWithoutUserFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    TourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
  }

  export type TourUncheckedUpdateWithoutUserFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type BookingCreateManyTourInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryCreateManyTourInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type UserFeedbackCreateManyTourInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutTourInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutTourInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpdateWithoutTourInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryCreateManyGuideInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryCreateManyDriverInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryUpdateWithoutGuideInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutGuideInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutGuideInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutDriverInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryDayCreateManyItineraryInput = {
    id?: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type CustomTourRequestCreateManyAssignedItineraryInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    interests?: CustomTourRequestCreateinterestsInput | string[]
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
  }

  export type UserFeedbackCreateManyItineraryInput = {
    id?: number
    userId: number
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type ItineraryDayUpdateWithoutItineraryInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateManyWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomTourRequestUpdateWithoutAssignedItineraryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: CustomTourRequestUpdateinterestsInput | string[]
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpdateWithoutItineraryInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCreateManyTourOperatorInput = {
    id?: number
    name: string
    description: string
    duration: number
    price: number
    category: string
    imageUrl: string
    rating?: number
    reviewCount?: number
    highlights?: TourCreatehighlightsInput | string[]
    isActive?: boolean
    maxGroupSize?: number
    difficulty?: string
    bestSeason?: string
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
  }

  export type TourUpdateWithoutTourOperatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutTourOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateManyWithoutTourOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    highlights?: TourUpdatehighlightsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxGroupSize?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    bestSeason?: StringFieldUpdateOperationsInput | string
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
  }

  export type FestivalBookingCreateManyFestivalInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUpdateWithoutFestivalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateManyWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRoomCreateManyHotelInput = {
    id?: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelBookingCreateManyHotelInput = {
    id?: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelRoomUpdateWithoutHotelInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelBookingUpdateWithoutHotelInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: HotelRoomUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingCreateManyRoomInput = {
    id?: number
    hotelId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateWithoutRoomInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateManyUserInput = {
    id?: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TourCountOutputTypeDefaultArgs instead
     */
    export type TourCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuideCountOutputTypeDefaultArgs instead
     */
    export type GuideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryCountOutputTypeDefaultArgs instead
     */
    export type ItineraryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourOperatorCountOutputTypeDefaultArgs instead
     */
    export type TourOperatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalCountOutputTypeDefaultArgs instead
     */
    export type FestivalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelCountOutputTypeDefaultArgs instead
     */
    export type HotelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelRoomCountOutputTypeDefaultArgs instead
     */
    export type HotelRoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAccountCountOutputTypeDefaultArgs instead
     */
    export type UserAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourDefaultArgs instead
     */
    export type TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InquiryDefaultArgs instead
     */
    export type InquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InquiryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestimonialDefaultArgs instead
     */
    export type TestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuideDefaultArgs instead
     */
    export type GuideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDefaultArgs instead
     */
    export type ItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDayDefaultArgs instead
     */
    export type ItineraryDayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomTourRequestDefaultArgs instead
     */
    export type CustomTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomTourRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourOperatorDefaultArgs instead
     */
    export type TourOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourOperatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalDefaultArgs instead
     */
    export type FestivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalBookingDefaultArgs instead
     */
    export type FestivalBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelDefaultArgs instead
     */
    export type HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelRoomDefaultArgs instead
     */
    export type HotelRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelBookingDefaultArgs instead
     */
    export type HotelBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAccountDefaultArgs instead
     */
    export type UserAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFeedbackDefaultArgs instead
     */
    export type UserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFeedbackDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}